#region Using directives
using System;
using System.Collections.Generic;
using System.Linq;
#endregion

namespace Blazorise.Docs.Models.ApiDocsDtos;

/// will be removed in package (specified in csproj)
/// Necessary dtos for working with api docs.
/// Can be generated by Source generator, but needs to be done after Blazorise.Extensions are solved.
/// This almost keeps parity with ApiDocsDtos in sg project.
public class ApiDocsForComponent
{
    #region Members

    private IReadOnlyList<ApiDocsForComponentMethod> methods;

    private IReadOnlyList<ApiDocsForComponentProperty> properties;

    private IReadOnlyList<ApiDocsForComponentProperty> parameters;

    private IReadOnlyList<ApiDocsForComponentProperty> events;

    #endregion

    #region Constructors

    public ApiDocsForComponent( Type type, string typeName, List<ApiDocsForComponentProperty> properties, List<ApiDocsForComponentMethod> methods, List<Type> inheritsFromChain, string category = null, string subcategory = null )
    {
        Type = type;
        TypeName = typeName;
        OwnProperties = properties;
        OwnMethods = methods;
        InheritsFromChain = inheritsFromChain;
        Category = category;
        Subcategory = subcategory;
    }

    #endregion

    #region Properties

    /// <summary>
    /// properties form the component and its parents
    /// </summary>
    public IReadOnlyList<ApiDocsForComponentProperty> Parameters
    {
        get
        {
            if ( parameters != null )
                return parameters;
            parameters = Properties.Where( x => !x.Type.IsEventType() ).ToList();
            return parameters;
        }
    }


    private IReadOnlyList<ApiDocsForComponentProperty> Properties
    {
        get
        {
            if ( properties != null )
                return properties;
            var tempList = new List<ApiDocsForComponentProperty>();
            tempList.AddRange( OwnProperties );
            foreach ( Type typeInheritFrom in InheritsFromChain )
            {
                bool success = ComponentsApiDocsSource.Instance.Components.TryGetValue( typeInheritFrom, out var component );
                if ( !success || component is null )
                    continue;
                string typeNameWoutGeneric = component.TypeName.Split( '<' ).First();//because inside cref (now inside <strong> it is wout the generic part (SomCom instead of SomCom<TValue>))
                tempList.AddRange( component.OwnProperties.Select( x => new ApiDocsForComponentProperty( x.Name, x.Type, x.TypeName, x.DefaultValueString,
                x.Summary.Replace( typeNameWoutGeneric, this.TypeName ),
                x.Remarks.Replace( typeNameWoutGeneric, this.TypeName ),
                x.IsBlazoriseEnum ) ) );
            }
            properties = tempList;
            return properties;

        }
    }

    public IReadOnlyList<ApiDocsForComponentProperty> Events
    {
        get
        {
            if ( events != null )
                return events;
            events = Properties.Where( x => x.Type.IsEventType() ).ToList();
            return events;
        }
    }

    /// <summary>
    /// only properties from the component, not from parents
    /// </summary>
    public IReadOnlyList<ApiDocsForComponentProperty> OwnProperties { get; set; }
    /// <summary>
    /// Methods from the component and its parents
    /// </summary>
    public IReadOnlyList<ApiDocsForComponentMethod> Methods
    {
        get
        {
            if ( methods != null )
                return methods;
            var tempList = new List<ApiDocsForComponentMethod>();
            tempList.AddRange( OwnMethods );
            foreach ( Type typeInheritFrom in InheritsFromChain )
            {
                bool success = ComponentsApiDocsSource.Instance.Components.TryGetValue( typeInheritFrom, out var component );
                if ( !success || component is null )
                    continue;
                tempList.AddRange( component.OwnMethods );
            }
            methods = tempList;
            return methods;
        }
    }

    public Type Type { get; set; }

    public string TypeName { get; }

    public string Category { get; }

    public string Subcategory { get; }



    /// <summary>
    /// Only methods from the component, not from parents
    /// </summary>
    public IReadOnlyList<ApiDocsForComponentMethod> OwnMethods { get; }


    //chain of inherited classes from component to BaseComponent
    public IReadOnlyList<Type> InheritsFromChain { get; }

    #endregion
}