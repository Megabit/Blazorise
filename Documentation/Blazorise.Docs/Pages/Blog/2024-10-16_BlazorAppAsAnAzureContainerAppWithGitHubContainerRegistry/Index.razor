@page "/blog/publishing-blazor-app-azure-container-app-github-container-registry"

<Seo Canonical="/blog/publishing-blazor-app-azure-container-app-github-container-registry" Title="Publishing a Blazor App as an Azure Container App with GitHub Container Registry" Description="Learn how to deploy a Blazor app on Azure Container Apps using GitHub Container Registry with a seamless CI/CD pipeline." ImageUrl="/img/blog/2024-10-16/hero.webp" />

<BlogPageImage Source="/img/blog/2024-10-16/hero.webp" Text="" />

<BlogPageTitle>
    Publishing a Blazor App as an Azure Container App with GitHub Container Registry
</BlogPageTitle>

<BlogPageParagraph>
    This article aims to guide you through a cost-effective solution for hosting a single ASP.NET Core app on Azure Container Apps. By the end, we will have set up a CI/CD pipeline using GitHub Actions to build the app as a container, push it to the GitHub Container Registry (GHCR), and configure Azure Container Apps to pull and deploy the image.
</BlogPageParagraph>

<BlogPageParagraph>
    We will cover all the necessary steps.
</BlogPageParagraph>

<BlogPageParagraph>
    There are multiple ways to deploy to Azure. We will discuss a few options but focus primarily on a vendor-agnostic solution—one that does not depend on any specific IDE and can easily be adapted for other cloud providers or hosting environments.
</BlogPageParagraph>

<BlogPageSubtitle>
    Creating the App
</BlogPageSubtitle>

<BlogPageParagraph>
    Start by creating a .NET 8 Blazor project using the following command:
</BlogPageParagraph>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry1" />

<BlogPageParagraph>
    Next, you'll need a <Code>Dockerfile</Code> to containerize your app. It can be easily generated by your IDE. In Visual Studio, right-click the project and select <Strong>Add</Strong> -> <Strong>Docker Support</Strong>. In JetBrains Rider, go to <Strong>Add</Strong> -> <Strong>Dockerfile</Strong>.
</BlogPageParagraph>

<BlogPageParagraph>
    Your <Code>Dockerfile</Code> should look something like this:
</BlogPageParagraph>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry2" />

<BlogPageParagraph>
    Once your Dockerfile is ready, push the project to a private GitHub repository. A private repository will help us explore how to handle authorization for pulling the container image from GitHub. Of course, a public repository will also work, but using a private one adds a layer of security.
</BlogPageParagraph>

<BlogPageSubtitle>
    Creating the App on Azure
</BlogPageSubtitle>

<BlogPageParagraph>
    We will use the Azure Portal to create the container app. Alternatively, you could do this through the Azure CLI or directly from the Visual Studio Publish wizard.
</BlogPageParagraph>

<BlogPageList Ordered>
    <BlogPageListItem>
        Go to the Azure Portal and search for <Strong>Container Apps</Strong>.
    </BlogPageListItem>
    <BlogPageListItem>
        Click <Strong>Create</Strong> and fill in the form, similar to the screenshot below:
<BlogPageImageModal ImageSource="img/blog/2024-10-16/img-18.png" ImageTitle="Container App Creation" />
    </BlogPageListItem>
</BlogPageList>

<BlogPageParagraph>
    For this tutorial, I’ve created a dedicated resource group called <Code>testingRG</Code>.
</BlogPageParagraph>

<BlogPageParagraph>
    During the process, you’ll need to create a <Strong>Container Apps Environment</Strong>. Just click <Code>New</Code>, provide a name, and leave the default options. This environment acts as the hosting environment for containerized apps, and we won't modify it in this tutorial.
</BlogPageParagraph>

<BlogPageList Ordered>
    <BlogPageListItem>
        In the <Strong>Resources</Strong> section, adjust the resource allocation to <Strong>0.25 CPU</Strong> and <Strong>0.5 GB</Strong> of memory. This keeps costs down. You can scale these settings later if needed.
<BlogPageImageModal ImageSource="img/blog/2024-10-16/img-17.png" ImageTitle="Resource Allocation" />
    </BlogPageListItem>
    <BlogPageListItem>
        Check the <Code>Use quickstart image</Code> option. This will deploy a basic container image, letting us focus on setting up the pipeline to deploy our Blazor app later.
    </BlogPageListItem>
</BlogPageList>

<BlogPageParagraph>
    After you finish these steps, click <Strong>Create</Strong> to deploy your new app. Once it’s ready, you can go to the resource and click on the <Strong>Application URL</Strong> to verify that the app is running. You should see a default "Hello World" message from the quick start image.
</BlogPageParagraph>

<BlogPageParagraph>
    Next, we’ll configure the deployment of our custom Blazor app.
</BlogPageParagraph>

<BlogPageSubtitle>
    CI/CD Pipeline (GitHub Actions)
</BlogPageSubtitle>

<BlogPageParagraph>
    The goal of this step is to create a GitHub Actions pipeline that will build the Docker image for our Blazor app, push it to GitHub Container Registry (GHCR), and deploy it to Azure Container Apps.
</BlogPageParagraph>

<BlogPageParagraph>
    Below is the full <Code>.yml</Code> file for the GitHub Actions workflow. I will explain the individual parts afterward.
</BlogPageParagraph>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry3" />

<Heading Size="HeadingSize.Is3">
    PACKAGE_NAME
</Heading>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry4" />

<BlogPageParagraph>
    <Code>PACKAGE_NAME</Code> is the identifier for the Docker image in GitHub Container Registry (GHCR). Since GitHub Packages uses the term "package" broadly (it can refer to NuGet packages, ZIP files, or container images), we're defining the repository (<Code>azurecontainerapptest</Code>) and the specific image (<Code>containertest</Code>). This variable is used throughout the workflow to ensure consistent naming for the image.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is3">
    Building and Pushing the Container Image
</Heading>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry5" />

<BlogPageParagraph>
    In this step, we are specifying the Dockerfile to containerize the Blazor app and using the <Code>tags</Code> parameter to name the container image. The image will be available at a location like <Code>ghcr.io/username/azurecontainerapptest/containertest:e446edd16995a225d60482ab21bd55bbac88623a</Code>, where <Code>username</Code> is your GitHub account name and <Code>e446edd16995a225d60482ab21bd55bbac88623a</Code> is the Git commit SHA.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is3">
    Azure Login
</Heading>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry6" />

<BlogPageParagraph>
    Here we log in to Azure using credentials stored in GitHub secrets. You must generate these credentials on Azure and then store them in GitHub, as described below.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is4">
    Generate secret
</Heading>

<BlogPageParagraph>
    On your local machine (or in the Azure Portal), run the following command to generate a service principal with the appropriate permissions. This assumes the <Anchor To="https://learn.microsoft.com/en-us/cli/azure/" Title="Link to Azure CLI">Azure CLI</Anchor> is installed.
</BlogPageParagraph>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry7" />

<BlogPageParagraph>
    The three variables here are:
</BlogPageParagraph>

<BlogPageList>
    <BlogPageListItem>
        the name of the container app: <Code>azurecontainerapptest3</Code> in my case
    </BlogPageListItem>
    <BlogPageListItem>
        <Code>--your-subscription-id--</Code>
    </BlogPageListItem>
    <BlogPageListItem>
        <Code>AzureContainerAppTest</Code> as the environment we created together with the continer app
    </BlogPageListItem>
</BlogPageList>

<BlogPageParagraph>
    You will get a JSON response similar to this:
</BlogPageParagraph>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry8" />

<Heading Size="HeadingSize.Is4">
    Store the secret on GitHub
</Heading>

<BlogPageParagraph>
    Take this JSON output and go to your GitHub repository:
</BlogPageParagraph>

<BlogPageList Ordered>
    <BlogPageListItem>
        Navigate to <Strong>Settings</Strong> -> <Strong>Secrets and variables</Strong> -> <Strong>Actions</Strong>.
    </BlogPageListItem>
    <BlogPageListItem>
        Add a new secret and paste the JSON as the value.
    </BlogPageListItem>
</BlogPageList>

<BlogPageParagraph>
    Use the secret name (e.g., <Code>AZURECONTAINERAPPTEST3_SPN</Code>) in the Azure login step.
</BlogPageParagraph>

<BlogPageImageModal ImageSource="img/blog/2024-10-16/img.png" ImageTitle="Adding Secret" />

<Heading Size="HeadingSize.Is3">
    Update container app
</Heading>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry9" />

<BlogPageParagraph>
    This command uses the Azure CLI to update the container app with the newly built image. The <Code>--image</Code> parameter points to the container image pushed to GHCR in the previous steps.
</BlogPageParagraph>

<BlogPageParagraph>
    Now, when you push your changes to the GitHub repository, the action will run the pipeline. However, there’s one more thing we need to handle—giving Azure access to the GHCR.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is3">
    Allowing Azure to Access GitHub Packages
</Heading>

<BlogPageParagraph>
    In order for Azure to pull the container image from GitHub Container Registry (GHCR), we need to grant it access by generating a Personal Access Token (PAT) from GitHub. Azure will use this PAT to authenticate against GHCR and pull the image.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is4">
    Generate a PAT (Personal Access Token)
</Heading>

<BlogPageList Ordered>
    <BlogPageListItem>
        Go to your GitHub account.
    </BlogPageListItem>
    <BlogPageListItem>
        Navigate to <Strong>Settings</Strong> -> <Strong>Developer settings</Strong> -> <Strong>Personal access tokens</Strong> -> <Strong>Tokens (classic)</Strong>.
    </BlogPageListItem>
    <BlogPageListItem>
        Generate a new token with the <Code>read:packages</Code> permission.
    </BlogPageListItem>
</BlogPageList>

<BlogPageParagraph>
    <Blockquote>
        Note: As of now, GitHub's fine-grained access tokens do not support package access, so you will need to use a classic PAT.
    </Blockquote>
</BlogPageParagraph>

<BlogPageParagraph>
    Once the token is generated, you will see it displayed only once, so make sure to copy the token.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is4">
    Configure Azure to Use the PAT
</Heading>

<BlogPageParagraph>
    Now, use the Azure CLI to set up access to the GitHub Container Registry using the generated PAT. Replace the values in the following command with your own:
</BlogPageParagraph>

<BlogPageSourceBlock Code="BlazorAppAsAnAzureContainerAppWithGitHubContainerRegistry10" />

<BlogPageParagraph>
    In this command:
</BlogPageParagraph>

<BlogPageList>
    <BlogPageListItem>
        <Code>--name</Code> specifies the name of the Azure Container App.
    </BlogPageListItem>
    <BlogPageListItem>
        <Code>--resource-group</Code> refers to the resource group where the app is deployed.
    </BlogPageListItem>
    <BlogPageListItem>
        <Code>--server</Code> is set to <Code>ghcr.io</Code>, the GitHub Container Registry server.
    </BlogPageListItem>
    <BlogPageListItem>
        <Code>--username</Code> should be your GitHub username.
    </BlogPageListItem>
    <BlogPageListItem>
        <Code>--password</Code> is the PAT you just generated.
    </BlogPageListItem>
</BlogPageList>

<Heading Size="HeadingSize.Is4">
    Verify the Secret in Azure
</Heading>

<BlogPageParagraph>
    Once the command is executed, the PAT is stored securely in Azure. You can verify this by navigating to your Azure Container App:
</BlogPageParagraph>

<BlogPageList Ordered>
    <BlogPageListItem>
        Go to <Strong>Settings</Strong> -> <Strong>Secrets</Strong>.
    </BlogPageListItem>
    <BlogPageListItem>
        You should see the registry credentials stored there.
    </BlogPageListItem>
</BlogPageList>

<BlogPageParagraph>
    This setup allows Azure to authenticate with GHCR and pull the container image during deployment.
</BlogPageParagraph>

<Heading Size="HeadingSize.Is4">
    Final Steps to Resolve Port Mismatch
</Heading>

<BlogPageParagraph>
    At this stage, the pipeline should run successfully, but the app might not work immediately due to a port mismatch. The error typically looks like:
</BlogPageParagraph>

<BlogPageParagraph>
    <Blockquote>
        "The TargetPort 80 does not match the listening port 8080."
    </Blockquote>
</BlogPageParagraph>

<BlogPageParagraph>
    To fix this:
</BlogPageParagraph>

<BlogPageList Ordered>
    <BlogPageListItem>
        Go to your Azure Container App in the portal.
    </BlogPageListItem>
    <BlogPageListItem>
        Navigate to <Strong>Settings</Strong> -> <Strong>Ingress</Strong>.
    </BlogPageListItem>
    <BlogPageListItem>
        Change the <Strong>TargetPort</Strong> to <Code>8080</Code> to match the port exposed in your Dockerfile.
    </BlogPageListItem>
</BlogPageList>

<BlogPageImageModal ImageSource="img/blog/2024-10-16/img-1.png" ImageTitle="Port Mismatch Fix" />

<BlogPageParagraph>
    Once updated, your app should now be running. You can verify this by going to <Strong>Overview</Strong> -> <Strong>Application URL</Strong> to check the live version of your app.
</BlogPageParagraph>

<BlogPageImageModal ImageSource="img/blog/2024-10-16/img-3.png" ImageTitle="App Running" />

<BlogPageSubtitle>
    Scaling to 0 Replicas
</BlogPageSubtitle>

<BlogPageParagraph>
    By default, even if you're not using your Azure Container App, you will incur costs. Running an app with the lowest resource settings (0.25 CPU and 0.5 GB RAM) costs approximately €5 per month, even during idle times. To avoid unnecessary charges when the app is not in use, you can scale the app down to 0 replicas.
</BlogPageParagraph>

<BlogPageParagraph>
    When scaled to 0 replicas, the app will automatically turn off when idle and only spin up when there is traffic. This can be useful for testing or development environments where the app doesn't need to be constantly running. However, this configuration is not suitable for production since it adds a delay when traffic first hits the app, as the container needs to start up again.
</BlogPageParagraph>

<BlogPageParagraph>
    From experience, the cold start time for an app scaling from 0 replicas usually takes around <Strong>20-30 seconds</Strong>, depending on the size and complexity of the container image (<Anchor To="https://github.com/microsoft/azure-container-apps/issues/997" Title="Link to source">source</Anchor>). For a simple Blazor app, the startup time should be about <Strong>20 seconds</Strong>. Additionally, after <Strong>5 minutes</Strong> of inactivity (the default idle timeout), the app will scale back down to 0 replicas (<Anchor To="https://azureway.cloud/azure-container-apps-scaling-part-3/" Title="Link to source">source</Anchor>).
</BlogPageParagraph>

<BlogPageParagraph>
    To configure scaling to 0 replicas:
</BlogPageParagraph>

<BlogPageList Ordered>
    <BlogPageListItem>
        Go to your Azure Container App in the portal.
    </BlogPageListItem>
    <BlogPageListItem>
        Navigate to <Strong>Scale</Strong> in the side menu.
    </BlogPageListItem>
    <BlogPageListItem>
        Set the <Strong>Minimum replicas</Strong> to <Code>0</Code> and <Strong>Maximum replicas</Strong> to your desired value (for example, <Code>1</Code>).
    </BlogPageListItem>
</BlogPageList>

<BlogPageImageModal ImageSource="img/blog/2024-10-16/img-14.png" ImageTitle="Scale Settings" />

<BlogPageParagraph>
    By doing this, the app will scale down to 0 replicas during periods of inactivity, and Azure will automatically bring it back online when traffic hits.
</BlogPageParagraph>

<BlogPageParagraph>
    This feature is an excellent way to save costs during development or testing phases without affecting the ability to scale back up when necessary.
</BlogPageParagraph>

<BlogPagePostInto UserName="Jan Tesař" ImageName="tesy" PostedOn="October 16th, 2024" Read="10 min" />
