/*!
 * chartjs-plugin-trendline v3.2.0
 * https://github.com/Makanz/chartjs-plugin-trendline
 * (c) 2025 Marcus Alsterfjord
 * Released under the MIT license
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).ChartJSTrendline=e()}(this,function(){"use strict";class t{constructor(){this.count=0,this.sumx=0,this.sumy=0,this.sumx2=0,this.sumxy=0,this.minx=Number.MAX_VALUE,this.maxx=Number.MIN_VALUE,this._cachedSlope=null,this._cachedIntercept=null,this._cacheValid=!1}add(t,e){this.sumx+=t,this.sumy+=e,this.sumx2+=t*t,this.sumxy+=t*e,t<this.minx&&(this.minx=t),t>this.maxx&&(this.maxx=t),this.count++,this._cacheValid=!1}slope(){return this._cacheValid||this._computeCoefficients(),this._cachedSlope}intercept(){return this._cacheValid||this._computeCoefficients(),this._cachedIntercept}f(t){return this.slope()*t+this.intercept()}fo(){return-this.intercept()/this.slope()}scale(){return this.slope()}_computeCoefficients(){const t=this.count*this.sumx2-this.sumx*this.sumx;this._cachedSlope=(this.count*this.sumxy-this.sumx*this.sumy)/t,this._cachedIntercept=(this.sumy-this._cachedSlope*this.sumx)/this.count,this._cacheValid=!0}}class e{constructor(){this.count=0,this.sumx=0,this.sumlny=0,this.sumx2=0,this.sumxlny=0,this.minx=Number.MAX_VALUE,this.maxx=Number.MIN_VALUE,this.hasValidData=!0,this.dataPoints=[],this._cachedGrowthRate=null,this._cachedCoefficient=null,this._cachedCorrelation=null,this._cacheValid=!1}add(t,e){if(e<=0)return void(this.hasValidData=!1);const i=Math.log(e);isFinite(i)?(this.sumx+=t,this.sumlny+=i,this.sumx2+=t*t,this.sumxlny+=t*i,t<this.minx&&(this.minx=t),t>this.maxx&&(this.maxx=t),this.dataPoints.push({x:t,y:e,lny:i}),this.count++,this._cacheValid=!1):this.hasValidData=!1}growthRate(){return!this.hasValidData||this.count<2?0:(this._cacheValid||this._computeCoefficients(),this._cachedGrowthRate)}coefficient(){return!this.hasValidData||this.count<2?1:(this._cacheValid||this._computeCoefficients(),this._cachedCoefficient)}f(t){if(!this.hasValidData||this.count<2)return 0;if(this._cacheValid||this._computeCoefficients(),Math.abs(this._cachedGrowthRate*t)>500)return 0;const e=this._cachedCoefficient*Math.exp(this._cachedGrowthRate*t);return isFinite(e)?e:0}correlation(){return!this.hasValidData||this.count<2?0:(this._cacheValid||this._computeCoefficients(),this._cachedCorrelation)}scale(){return this.growthRate()}_computeCoefficients(){if(!this.hasValidData||this.count<2)return this._cachedGrowthRate=0,this._cachedCoefficient=1,this._cachedCorrelation=0,void(this._cacheValid=!0);const t=this.count*this.sumx2-this.sumx*this.sumx;if(Math.abs(t)<1e-10)return this._cachedGrowthRate=0,this._cachedCoefficient=1,this._cachedCorrelation=0,void(this._cacheValid=!0);this._cachedGrowthRate=(this.count*this.sumxlny-this.sumx*this.sumlny)/t;const e=(this.sumlny-this._cachedGrowthRate*this.sumx)/this.count;this._cachedCoefficient=Math.exp(e);const i=this.sumlny/this.count;let s=0,a=0;for(const t of this.dataPoints){const n=e+this._cachedGrowthRate*t.x;s+=Math.pow(t.lny-i,2),a+=Math.pow(t.lny-n,2)}this._cachedCorrelation=0===s?1:Math.max(0,1-a/s),this._cacheValid=!0}}const i=(i,s,a,n,l)=>{const o=a.yAxisID||"y",h=i.controller.chart.scales[o]||l,c=!!a.trendlineExponential,r=a.trendlineExponential||a.trendlineLinear||{},d=a.borderColor||"rgba(169,169,169, .6)",{colorMin:u=d,colorMax:x=d,width:f=a.borderWidth||3,lineStyle:m="solid",fillColor:y=!1}=r;let p=r.trendoffset||0;const{color:g=d,text:_=(c?"Exponential Trendline":"Trendline"),display:b=!0,displayValue:V=!0,offset:w=10,percentage:F=!1}=r&&r.label||{},{family:C="'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:M=12}=r&&r.label&&r.label.font||{},P=i.controller.chart.options,N="object"==typeof P.parsing?P.parsing:void 0,D=r?.xAxisKey||N?.xAxisKey||"x",S=r?.yAxisKey||N?.yAxisKey||"y";let T=c?new e:new t;Math.abs(p)>=a.data.length&&(p=0);let L=0;if(p>0){const t=a.data.slice(p).findIndex(t=>null!=t);L=-1!==t?p+t:a.data.length}else{const t=a.data.findIndex(t=>null!=t);L=-1!==t?t:a.data.length}let v,A,E,G,R=L<a.data.length&&"object"==typeof a.data[L];if(a.data.forEach((t,e)=>{if(null!=t&&!(p>0&&e<L||p<0&&e>=a.data.length+p))if(["time","timeseries"].includes(n.options.type)&&R){let e=null!=t[D]?t[D]:t.t;const i=t[S];null==e||void 0===e||null==i||isNaN(i)||T.add(new Date(e).getTime(),i)}else if(R){const e=t[D],i=t[S],s=null!=e&&!isNaN(e),a=null!=i&&!isNaN(i);s&&a&&T.add(e,i)}else if(["time","timeseries"].includes(n.options.type)&&!R){const s=i.controller.chart.data.labels;if(s&&s[e]&&null!=t&&!isNaN(t)){const i=new Date(s[e]).getTime();isNaN(i)||T.add(i,t)}}else null==t||isNaN(t)||T.add(e,t)}),T.count<2)return;const I=i.controller.chart.chartArea;if(r.projection){let t=[];if(c){const e=n.getValueForPixel(I.left),i=T.f(e);t.push({x:e,y:i});const s=n.getValueForPixel(I.right),a=T.f(s);t.push({x:s,y:a})}else{const e=T.slope(),i=T.intercept();if(Math.abs(e)>1e-6){const s=h.getValueForPixel(I.top),a=(s-i)/e;t.push({x:a,y:s});const n=h.getValueForPixel(I.bottom),l=(n-i)/e;t.push({x:l,y:n})}else t.push({x:n.getValueForPixel(I.left),y:i}),t.push({x:n.getValueForPixel(I.right),y:i});const s=n.getValueForPixel(I.left),a=T.f(s);t.push({x:s,y:a});const l=n.getValueForPixel(I.right),o=T.f(l);t.push({x:l,y:o})}const e=n.getValueForPixel(I.left),i=n.getValueForPixel(I.right),s=[h.getValueForPixel(I.top),h.getValueForPixel(I.bottom)].filter(t=>isFinite(t)),a=s.length>0?Math.min(...s):-1/0,l=s.length>0?Math.max(...s):1/0;let o=t.filter(t=>isFinite(t.x)&&isFinite(t.y)&&t.x>=e&&t.x<=i&&t.y>=a&&t.y<=l);o=o.filter((t,e,i)=>e===i.findIndex(e=>Math.abs(e.x-t.x)<1e-4&&Math.abs(e.y-t.y)<1e-4)),o.length>=2?(o.sort((t,e)=>t.x-e.x||t.y-e.y),v=n.getPixelForValue(o[0].x),A=h.getPixelForValue(o[0].y),E=n.getPixelForValue(o[o.length-1].x),G=h.getPixelForValue(o[o.length-1].y)):(v=NaN,A=NaN,E=NaN,G=NaN)}else{const t=T.f(T.minx),e=T.f(T.maxx);v=n.getPixelForValue(T.minx),A=h.getPixelForValue(t),E=n.getPixelForValue(T.maxx),G=h.getPixelForValue(e)}let k=null;if(isFinite(v)&&isFinite(A)&&isFinite(E)&&isFinite(G)&&(k=function(t,e,i,s,a){let n=i-t,l=s-e,o=0,h=1;const c=[-n,n,-l,l],r=[t-a.left,a.right-t,e-a.top,a.bottom-e];for(let t=0;t<4;t++)if(0===c[t]){if(r[t]<0)return null}else{const e=r[t]/c[t];if(c[t]<0){if(e>h)return null;o=Math.max(o,e)}else{if(e<o)return null;h=Math.min(h,e)}}if(o>h)return null;return{x1:t+o*n,y1:e+o*l,x2:t+h*n,y2:e+h*l}}(v,A,E,G,I)),k)if(v=k.x1,A=k.y1,E=k.x2,G=k.y2,Math.abs(v-E)<.5&&Math.abs(A-G)<.5);else{s.lineWidth=f,((t,e)=>{switch(e){case"dotted":t.setLineDash([2,2]);break;case"dashed":t.setLineDash([8,3]);break;case"dashdot":t.setLineDash([8,3,2,3]);break;default:t.setLineDash([])}})(s,m),(({ctx:t,x1:e,y1:i,x2:s,y2:a,colorMin:n,colorMax:l})=>{if(isFinite(e)&&isFinite(i)&&isFinite(s)&&isFinite(a)){t.beginPath(),t.moveTo(e,i),t.lineTo(s,a);try{const o=s-e,h=a-i,c=Math.sqrt(o*o+h*h);if(c<.01)console.warn("Gradient vector too small, using solid color:",{x1:e,y1:i,x2:s,y2:a,length:c}),t.strokeStyle=n;else{let o=t.createLinearGradient(e,i,s,a);o.addColorStop(0,n),o.addColorStop(1,l),t.strokeStyle=o}}catch(e){console.warn("Gradient creation failed, using solid color:",e),t.strokeStyle=n}t.stroke(),t.closePath()}else console.warn("Cannot draw trendline: coordinates contain non-finite values",{x1:e,y1:i,x2:s,y2:a})})({ctx:s,x1:v,y1:A,x2:E,y2:G,colorMin:u,colorMax:x}),y&&((t,e,i,s,a,n,l)=>{isFinite(e)&&isFinite(i)&&isFinite(s)&&isFinite(a)&&isFinite(n)?(t.beginPath(),t.moveTo(e,i),t.lineTo(s,a),t.lineTo(s,n),t.lineTo(e,n),t.lineTo(e,i),t.closePath(),t.fillStyle=l,t.fill()):console.warn("Cannot fill below trendline: coordinates contain non-finite values",{x1:e,y1:i,x2:s,y2:a,drawBottom:n})})(s,v,A,E,G,I.bottom,y);const t=Math.atan2(G-A,E-v);if(r.label&&!1!==b){let e=_;if(V)if(c){const t=T.coefficient(),i=T.growthRate();e=`${_} (a=${t.toFixed(2)}, b=${i.toFixed(2)})`}else{const t=T.slope();e=`${_} (Slope: ${F?(100*t).toFixed(2)+"%":t.toFixed(2)})`}((t,e,i,s,a,n,l,o,h,c,r)=>{t.font=`${c}px ${h}`,t.fillStyle=o;const d=t.measureText(e).width,u=(i+a)/2,x=(s+n)/2;t.save(),t.translate(u,x),t.rotate(l);const f=-d/2,m=r;t.fillText(e,f,m),t.restore()})(s,e,v,A,E,G,t,g,C,M,w)}}};const s={id:"chartjs-plugin-trendline",afterDatasetsDraw:t=>{const e=t.ctx,{xScale:s,yScale:a}=(t=>{let e,i;for(const s of Object.values(t.scales))if(s.isHorizontal()?e=s:i=s,e&&i)break;return{xScale:e,yScale:i}})(t);t.data.datasets.map((t,e)=>({dataset:t,index:e})).filter(t=>t.dataset.trendlineLinear||t.dataset.trendlineExponential).sort((t,e)=>{const i=t.dataset.order??0,s=e.dataset.order??0;return 0===i&&0!==s?1:0===s&&0!==i?-1:i-s}).forEach(({dataset:n,index:l})=>{if((n.alwaysShowTrendline||t.isDatasetVisible(l))&&n.data.length>1){const o=t.getDatasetMeta(l);i(o,e,n,s,a)}}),e.setLineDash([])},beforeInit:t=>{t.data.datasets.forEach(e=>{const i=e.trendlineLinear||e.trendlineExponential;if(i&&i.label){const s=i.label,a=t.legend.options.labels.generateLabels;t.legend.options.labels.generateLabels=function(t){const n=a(t),l=i.legend;return l&&!1!==l.display&&n.push({text:l.text||s+" (Trendline)",strokeStyle:l.color||e.borderColor||"rgba(169,169,169, .6)",fillStyle:l.fillStyle||"transparent",lineCap:l.lineCap||"butt",lineDash:l.lineDash||[],lineWidth:l.width||1}),n}}})}};return"undefined"!=typeof window&&window.Chart&&(window.Chart.hasOwnProperty("register")?window.Chart.register(s):window.Chart.plugins.register(s)),s});
//# sourceMappingURL=chartjs-plugin-trendline.min.js.map
