/*! Cropper.js v2.0.0-beta.1 | (c) 2015-present Chen Fengyuan | MIT */
const t = "undefined" != typeof window && void 0 !== window.document, e = t ? window : {}, s = !!t && "ontouchstart" in e.document.documentElement, i = !!t && "PointerEvent" in e, n = "cropper", o = "cropper-canvas", a = "cropper-crosshair", r = "cropper-grid", h = "cropper-handle", c = "cropper-image", l = "cropper-selection", d = "cropper-shade", p = "cropper-viewer", u = "select", $ = "move", m = "scale", g = "rotate", b = "transform", f = "none", v = "n-resize", w = "e-resize", y = "s-resize", C = "w-resize", k = "ne-resize", x = "nw-resize", S = "se-resize", z = "sw-resize", A = "action", E = s ? "touchend touchcancel" : "mouseup", M = s ? "touchmove" : "mousemove", T = s ? "touchstart" : "mousedown", D = i ? "pointerdown" : T, P = i ? "pointermove" : M, I = i ? "pointerup pointercancel" : E, O = "error", R = "keydown", N = "load", Y = "resize", X = "wheel", L = "action", W = "actionend", j = "actionmove", q = "actionstart", B = "change", H = "transform"; function K(t) { return "string" == typeof t } const U = Number.isNaN || e.isNaN; function F(t) { return "number" == typeof t && !U(t) } function Z(t) { return F(t) && t > 0 && t < 1 / 0 } function G(t) { return void 0 === t } function J(t) { return "object" == typeof t && null !== t } const { hasOwnProperty: Q } = Object.prototype; function V(t) { if (!J(t)) return !1; try { const { constructor: e } = t, { prototype: s } = e; return e && s && Q.call(s, "isPrototypeOf") } catch (t) { return !1 } } function _(t) { return "function" == typeof t } function tt(t) { return "object" == typeof t && null !== t && 1 === t.nodeType } const et = /([a-z\d])([A-Z])/g; function st(t) { return String(t).replace(et, "$1-$2").toLowerCase() } const it = /-[A-z\d]/g; function nt(t) { return t.replace(it, (t => t.slice(1).toUpperCase())) } const ot = /\s\s*/; function at(t, e, s, i) { e.trim().split(ot).forEach((e => { t.removeEventListener(e, s, i) })) } function rt(t, e, s, i) { e.trim().split(ot).forEach((e => { t.addEventListener(e, s, i) })) } function ht(t, e, s, i) { rt(t, e, s, Object.assign(Object.assign({}, i), { once: !0 })) } const ct = { bubbles: !0, cancelable: !0, composed: !0 }; function lt(t, e, s, i) { return t.dispatchEvent(new CustomEvent(e, Object.assign(Object.assign(Object.assign({}, ct), { detail: s }), i))) } const dt = Promise.resolve(); function pt(t, e) { return e ? dt.then(t ? e.bind(t) : e) : dt } function ut(t) { const { documentElement: s } = t.ownerDocument, i = t.getBoundingClientRect(); return { left: i.left + (e.pageXOffset - s.clientLeft), top: i.top + (e.pageYOffset - s.clientTop) } } const $t = /deg|g?rad|turn$/i; function mt(t) { const e = parseFloat(t) || 0; if (0 !== e) { const [s = "rad"] = String(t).match($t) || []; switch (s.toLowerCase()) { case "deg": return e / 360 * (2 * Math.PI); case "grad": return e / 400 * (2 * Math.PI); case "turn": return e * (2 * Math.PI) } } return e } function gt(t, e = "contain") { const { aspectRatio: s } = t; let { width: i, height: n } = t; const o = Z(i), a = Z(n); if (o && a) { const t = n * s; "contain" === e && t > i || "cover" === e && t < i ? n = i / s : i = n * s } else o ? n = i / s : a && (i = n * s); return { width: i, height: n } } const bt = /left|top|width|height/i, ft = new WeakMap, vt = new WeakMap, wt = new Map, yt = e.document && Array.isArray(e.document.adoptedStyleSheets) && "replaceSync" in e.CSSStyleSheet.prototype; class Ct extends HTMLElement { constructor() { var t, e; super(), this.shadowRootMode = "open", this.slottable = !0; const s = null === (e = null === (t = Object.getPrototypeOf(this)) || void 0 === t ? void 0 : t.constructor) || void 0 === e ? void 0 : e.$name; s && wt.set(s, this.tagName.toLowerCase()) } get $sharedStyle() { return (this.themeColor ? `:host{--theme-color: ${this.themeColor};}` : "") + ":host([hidden]){display:none!important}" } static get observedAttributes() { return ["shadow-root-mode", "slottable", "theme-color"] } attributeChangedCallback(t, e, s) { if (Object.is(s, e)) return; const i = nt(t); let n = s; switch (typeof this[i]) { case "boolean": n = null !== s && "false" !== s; break; case "number": n = Number(s) }switch (this[i] = n, t) { case "theme-color": { const t = vt.get(this), e = this.$sharedStyle; t && e && (yt ? t.replaceSync(e) : t.textContent = e); break } } } $propertyChangedCallback(t, e, s) { if (!Object.is(s, e)) switch (t = st(t), typeof s) { case "boolean": !0 === s ? this.hasAttribute(t) || this.setAttribute(t, "") : this.removeAttribute(t); break; case "number": s = U(s) ? "" : String(s); default: s ? this.getAttribute(t) !== s && this.setAttribute(t, s) : this.removeAttribute(t) } } connectedCallback() { Object.getPrototypeOf(this).constructor.observedAttributes.forEach((t => { const e = nt(t); let s = this[e]; G(s) || this.$propertyChangedCallback(e, void 0, s), Object.defineProperty(this, e, { enumerable: !0, configurable: !0, get: () => s, set(t) { const i = s; s = t, this.$propertyChangedCallback(e, i, t) } }) })); const t = this.attachShadow({ mode: this.shadowRootMode || "open" }); if (this.shadowRoot || ft.set(this, t), vt.set(this, this.$addStyles(this.$sharedStyle)), this.$style && this.$addStyles(this.$style), this.$template) { const e = document.createElement("template"); e.innerHTML = this.$template, t.appendChild(e.content) } if (this.slottable) { const e = document.createElement("slot"); t.appendChild(e) } } disconnectedCallback() { vt.has(this) && vt.delete(this), ft.has(this) && ft.delete(this) } $getTagNameOf(t) { var e; return null !== (e = wt.get(t)) && void 0 !== e ? e : t } $setStyles(t) { return Object.keys(t).forEach((e => { let s = t[e]; F(s) && (s = 0 !== s && bt.test(e) ? `${s}px` : String(s)), this.style[e] = s })), this } $getShadowRoot() { return this.shadowRoot || ft.get(this) } $addStyles(t) { let e; const s = this.$getShadowRoot(); return yt ? (e = new CSSStyleSheet, e.replaceSync(t), s.adoptedStyleSheets = s.adoptedStyleSheets.concat(e)) : (e = document.createElement("style"), e.textContent = t, s.appendChild(e)), e } $emit(t, e, s) { return lt(this, t, e, s) } $nextTick(t) { return pt(this, t) } static $define(s, i) { J(s) && (i = s, s = ""), s || (s = this.$name || this.name), s = st(s), t && e.customElements && !e.customElements.get(s) && customElements.define(s, this, i) } } Ct.$version = "2.0.0-beta.1"; class kt extends Ct { constructor() { super(...arguments), this.$onPointerDown = null, this.$onPointerMove = null, this.$onPointerUp = null, this.$onWheel = null, this.$wheeling = !1, this.$pointers = new Map, this.$style = ':host{display:block;min-height:100px;min-width:200px;overflow:hidden;position:relative;touch-action:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}:host([background]){background-color:#fff;background-image:repeating-linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc),repeating-linear-gradient(45deg,#ccc 25%,transparent 0,transparent 75%,#ccc 0,#ccc);background-image:repeating-conic-gradient(#ccc 0 25%,#fff 0 50%);background-position:0 0,.5rem .5rem;background-size:1rem 1rem}:host([disabled]){pointer-events:none}:host([disabled]):after{bottom:0;content:"";cursor:not-allowed;display:block;left:0;pointer-events:none;position:absolute;right:0;top:0}', this.$action = "none", this.background = !1, this.disabled = !1, this.scaleStep = .1, this.themeColor = "#39f" } static get observedAttributes() { return super.observedAttributes.concat(["background", "disabled", "scale-step"]) } connectedCallback() { super.connectedCallback(), this.disabled || this.$bind() } disconnectedCallback() { this.disabled || this.$unbind(), super.disconnectedCallback() } $propertyChangedCallback(t, e, s) { if (!Object.is(s, e) && (super.$propertyChangedCallback(t, e, s), "disabled" === t)) s ? this.$unbind() : this.$bind() } $bind() { this.$onPointerDown || (this.$onPointerDown = this.$handlePointerDown.bind(this), rt(this, D, this.$onPointerDown)), this.$onPointerMove || (this.$onPointerMove = this.$handlePointerMove.bind(this), rt(this.ownerDocument, P, this.$onPointerMove)), this.$onPointerUp || (this.$onPointerUp = this.$handlePointerUp.bind(this), rt(this.ownerDocument, I, this.$onPointerUp)), this.$onWheel || (this.$onWheel = this.$handleWheel.bind(this), rt(this, "wheel", this.$onWheel, { passive: !1, capture: !0 })) } $unbind() { this.$onPointerDown && (at(this, D, this.$onPointerDown), this.$onPointerDown = null), this.$onPointerMove && (at(this.ownerDocument, P, this.$onPointerMove), this.$onPointerMove = null), this.$onPointerUp && (at(this.ownerDocument, I, this.$onPointerUp), this.$onPointerUp = null), this.$onWheel && (at(this, "wheel", this.$onWheel, { capture: !0 }), this.$onWheel = null) } $handlePointerDown(t) { const { buttons: e, button: s, type: i } = t; if (this.disabled || ("pointerdown" === i && "mouse" === t.pointerType || "mousedown" === i) && (F(e) && 1 !== e || F(s) && 0 !== s || t.ctrlKey)) return; const { $pointers: n } = this; let o = ""; if (t.changedTouches) Array.from(t.changedTouches).forEach((({ identifier: t, pageX: e, pageY: s }) => { n.set(t, { startX: e, startY: s, endX: e, endY: s }) })); else { const { pointerId: e = 0, pageX: s, pageY: i } = t; n.set(e, { startX: s, startY: i, endX: s, endY: i }) } n.size > 1 ? o = "transform" : tt(t.target) && (o = t.target.action || t.target.getAttribute("action") || ""), !1 !== this.$emit("actionstart", { action: o, relatedEvent: t }) && (t.preventDefault(), this.$action = o, this.style.willChange = "transform") } $handlePointerMove(t) { const { $action: e, $pointers: s } = this; if (this.disabled || "none" === e || 0 === s.size) return; if (!1 === this.$emit("actionmove", { action: e, relatedEvent: t })) return; if (t.preventDefault(), t.changedTouches) Array.from(t.changedTouches).forEach((({ identifier: t, pageX: e, pageY: i }) => { const n = s.get(t); n && Object.assign(n, { endX: e, endY: i }) })); else { const { pointerId: e = 0, pageX: i, pageY: n } = t, o = s.get(e); o && Object.assign(o, { endX: i, endY: n }) } const i = { action: e, relatedEvent: t }; if ("transform" === e) { const e = new Map(s); let n = 0, o = 0, a = 0, r = 0, h = t.pageX, c = t.pageY; s.forEach(((t, s) => { e.delete(s), e.forEach((e => { let s = e.startX - t.startX, i = e.startY - t.startY, l = e.endX - t.endX, d = e.endY - t.endY, p = 0, u = 0, $ = 0, m = 0; if (0 === s ? i < 0 ? $ = 2 * Math.PI : i > 0 && ($ = Math.PI) : s > 0 ? $ = Math.PI / 2 + Math.atan(i / s) : s < 0 && ($ = 1.5 * Math.PI + Math.atan(i / s)), 0 === l ? d < 0 ? m = 2 * Math.PI : d > 0 && (m = Math.PI) : l > 0 ? m = Math.PI / 2 + Math.atan(d / l) : l < 0 && (m = 1.5 * Math.PI + Math.atan(d / l)), m > 0 || $ > 0) { const s = m - $, i = Math.abs(s); i > n && (n = i, a = s, h = (t.startX + e.startX) / 2, c = (t.startY + e.startY) / 2) } if (s = Math.abs(s), i = Math.abs(i), l = Math.abs(l), d = Math.abs(d), s > 0 && i > 0 ? p = Math.sqrt(s * s + i * i) : s > 0 ? p = s : i > 0 && (p = i), l > 0 && d > 0 ? u = Math.sqrt(l * l + d * d) : l > 0 ? u = l : d > 0 && (u = d), p > 0 && u > 0) { const s = (u - p) / p, i = Math.abs(s); i > o && (o = i, r = s, h = (t.startX + e.startX) / 2, c = (t.startY + e.startY) / 2) } })) })); const l = n > 0, d = o > 0; l && d ? (i.rotate = a, i.scale = r, i.centerX = h, i.centerY = c) : l ? (i.action = "rotate", i.rotate = a, i.centerX = h, i.centerY = c) : d ? (i.action = "scale", i.scale = r, i.centerX = h, i.centerY = c) : i.action = "none" } else { const [t] = Array.from(s.values()); Object.assign(i, t) } s.forEach((t => { t.startX = t.endX, t.startY = t.endY })), "none" !== i.action && this.$emit("action", i, { cancelable: !1 }) } $handlePointerUp(t) { const { $action: e, $pointers: s } = this; if (!this.disabled && "none" !== e && !1 !== this.$emit("actionend", { action: e, relatedEvent: t })) { if (t.preventDefault(), t.changedTouches) Array.from(t.changedTouches).forEach((({ identifier: t }) => { s.delete(t) })); else { const { pointerId: e = 0 } = t; s.delete(e) } 0 === s.size && (this.style.willChange = "", this.$action = "none") } } $handleWheel(t) { if (this.disabled) return; if (t.preventDefault(), this.$wheeling) return; this.$wheeling = !0, setTimeout((() => { this.$wheeling = !1 }), 50); const e = (t.deltaY > 0 ? -1 : 1) * this.scaleStep; this.$emit("action", { action: "scale", scale: e, relatedEvent: t }, { cancelable: !1 }) } $setAction(t) { return K(t) && (this.$action = t), this } $toCanvas(t) { return new Promise(((e, s) => { if (!this.isConnected) return void s(new Error("The current element is not connected to the DOM.")); const i = document.createElement("canvas"), n = this.offsetWidth, o = this.offsetHeight; i.width = n, i.height = o; const a = this.querySelector(this.$getTagNameOf("cropper-image")); a ? a.$ready().then((s => { const r = i.getContext("2d"); if (r) { const [e, h, c, l, d, p] = a.$getTransform(), u = s.naturalWidth / 2, $ = s.naturalHeight / 2; r.fillStyle = "transparent", r.fillRect(0, 0, n, o), V(t) && _(t.beforeDraw) && t.beforeDraw.call(this, r, i), r.save(), r.translate(u, $), r.transform(e, h, c, l, d, p), r.translate(-u, -$), r.drawImage(s, 0, 0), r.restore() } e(i) })).catch(s) : e(i) })).then((e => { if (V(t) && (Z(t.width) || Z(t.height))) { let { width: s, height: i } = e; if (({ width: s, height: i } = gt({ aspectRatio: s / i, width: t.width, height: t.height })), s !== e.width) { const t = document.createElement("canvas"), n = t.getContext("2d"); return t.width = s, t.height = i, n && n.drawImage(e, 0, 0, s, i), t } } return e })) } } kt.$name = "cropper-canvas", kt.$version = "2.0.0-beta.1"; const xt = new WeakMap, St = ["alt", "crossorigin", "decoding", "importance", "loading", "referrerpolicy", "sizes", "src", "srcset"]; class zt extends Ct { constructor() { super(...arguments), this.$matrix = [1, 0, 0, 1, 0, 0], this.$onLoad = null, this.$onCanvasAction = null, this.$style = ":host{display:inline-block}img{display:block;height:100%;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;width:100%}", this.$image = new Image, this.rotatable = !0, this.scalable = !0, this.skewable = !0, this.slottable = !1, this.translatable = !0 } set $canvas(t) { xt.set(this, t) } get $canvas() { return xt.get(this) } static get observedAttributes() { return super.observedAttributes.concat(St, ["rotatable", "scalable", "skewable", "translatable"]) } attributeChangedCallback(t, e, s) { Object.is(s, e) || (super.attributeChangedCallback(t, e, s), St.includes(t) && this.$image.setAttribute(t, s)) } connectedCallback() { super.connectedCallback(); const { $image: t } = this, e = this.closest(this.$getTagNameOf("cropper-canvas")); e && (this.$canvas = e, this.$setStyles({ position: "absolute" }), this.$onCanvasAction = this.$handleAction.bind(this), rt(e, "action", this.$onCanvasAction)), this.$onLoad = this.$handleLoad.bind(this), rt(t, "load", this.$onLoad), this.$getShadowRoot().appendChild(t) } disconnectedCallback() { const { $image: t, $canvas: e } = this; e && this.$onCanvasAction && (at(e, "action", this.$onCanvasAction), this.$onCanvasAction = null), t && this.$onLoad && (at(t, "load", this.$onLoad), this.$onLoad = null), this.$getShadowRoot().removeChild(t), super.disconnectedCallback() } $handleLoad() { const { $image: t } = this; this.$setStyles({ width: t.naturalWidth, height: t.naturalHeight }), this.$canvas && this.$center("cover") } $handleAction(t) { if (this.hidden || !(this.rotatable || this.scalable || this.translatable)) return; const { $canvas: e } = this, { detail: s } = t; if (s) { const { relatedEvent: t } = s; let { action: i } = s; switch ("transform" !== i || this.rotatable && this.scalable || (i = this.rotatable ? "rotate" : this.scalable ? "scale" : "none"), i) { case "move": if (this.translatable) { const i = this.$getTagNameOf("cropper-selection"); let n = e.querySelector(i); n && n.multiple && !n.active && (n = e.querySelector(`${i}[active]`)), n && !n.hidden && n.movable && t && n.contains(t.target) || this.$move(s.endX - s.startX, s.endY - s.startY) } break; case "rotate": if (this.rotatable) if (t) { const { x: e, y: i } = this.getBoundingClientRect(); this.$rotate(s.rotate, t.clientX - e, t.clientY - i) } else this.$rotate(s.rotate); break; case "scale": if (this.scalable) if (t) { const { x: e, y: i } = this.getBoundingClientRect(); this.$zoom(s.scale, t.clientX - e, t.clientY - i) } else this.$zoom(s.scale); break; case "transform": if (this.rotatable && this.scalable) { const { rotate: e } = s; let { scale: i } = s; i < 0 ? i = 1 / (1 - i) : i += 1; const n = Math.cos(e), o = Math.sin(e), [a, r, h, c] = [n * i, o * i, -o * i, n * i]; if (t) { const e = this.getBoundingClientRect(), s = t.clientX - e.x, i = t.clientY - e.y, [n, o, l, d] = this.$matrix, p = e.width / 2, u = i - e.height / 2, $ = ((s - p) * d - l * u) / (n * d - l * o), m = (u - o * $) / d; this.$transform(a, r, h, c, $ * (1 - a) + m * h, m * (1 - c) + $ * r) } else this.$transform(a, r, h, c, 0, 0) } } } } $ready(t) { const { $image: e } = this, s = new Promise(((t, s) => { const i = new Error("Failed to load the image source"); if (e.complete) e.naturalWidth > 0 && e.naturalHeight > 0 ? t(e) : s(i); else { const n = () => { at(e, "error", o), t(e) }, o = () => { at(e, "load", n), s(i) }; ht(e, "load", n), ht(e, "error", o) } })); return _(t) && s.then((e => (t(e), e))), s } $center(t) { const { parentElement: e } = this; if (!e) return this; const s = e.getBoundingClientRect(), i = s.width, n = s.height, { x: o, y: a, width: r, height: h } = this.getBoundingClientRect(), c = o + r / 2, l = a + h / 2, d = s.x + i / 2, p = s.y + n / 2; if (this.$move(d - c, p - l), t && (r !== i || h !== n)) { const e = i / r, s = n / h; switch (t) { case "cover": this.$scale(Math.max(e, s)); break; case "contain": this.$scale(Math.min(e, s)) } } return this } $move(t, e = t) { if (this.translatable && F(t) && F(e)) { const [s, i, n, o] = this.$matrix, a = (t * o - n * e) / (s * o - n * i), r = (e - i * a) / o; this.$translate(a, r) } return this } $moveTo(t, e = t) { if (this.translatable && F(t) && F(e)) { const [s, i, n, o] = this.$matrix, a = (t * o - n * e) / (s * o - n * i), r = (e - i * a) / o; this.$setTransform(s, i, n, o, a, r) } return this } $rotate(t, e, s) { if (this.rotatable) { const i = mt(t), n = Math.cos(i), o = Math.sin(i), [a, r, h, c] = [n, o, -o, n]; if (F(e) && F(s)) { const [t, i, n, o] = this.$matrix, { width: l, height: d } = this.getBoundingClientRect(), p = s - d / 2, u = ((e - l / 2) * o - n * p) / (t * o - n * i), $ = (p - i * u) / o; this.$transform(a, r, h, c, u * (1 - a) - $ * h, $ * (1 - c) - u * r) } else this.$transform(a, r, h, c, 0, 0) } return this } $zoom(t, e, s) { if (!this.scalable || 0 === t) return this; if (t < 0 ? t = 1 / (1 - t) : t += 1, F(e) && F(s)) { const [i, n, o, a] = this.$matrix, { width: r, height: h } = this.getBoundingClientRect(), c = s - h / 2, l = ((e - r / 2) * a - o * c) / (i * a - o * n), d = (c - n * l) / a; this.$transform(t, 0, 0, t, l * (1 - t), d * (1 - t)) } else this.$scale(t); return this } $scale(t, e = t) { return this.scalable && this.$transform(t, 0, 0, e, 0, 0), this } $skew(t, e = 0) { if (this.skewable) { const s = mt(t), i = mt(e); this.$transform(1, Math.tan(i), Math.tan(s), 1, 0, 0) } return this } $translate(t, e = t) { return this.translatable && F(t) && F(e) && this.$transform(1, 0, 0, 1, t, e), this } $transform(t, e, s, i, n, o) { if (F(t) && F(e) && F(s) && F(i) && F(n) && F(o)) { const [a, r, h, c, l, d] = this.$matrix, [p, u, $, m, g, b] = [t, e, s, i, n, o]; return this.$setTransform(a * p + h * u, r * p + c * u, a * $ + h * m, r * $ + c * m, a * g + h * b + l, r * g + c * b + d) } return this } $setTransform(t, e, s, i, n, o) { if ((this.rotatable || this.scalable || this.skewable || this.translatable) && (Array.isArray(t) && ([t, e, s, i, n, o] = t), F(t) && F(e) && F(s) && F(i) && F(n) && F(o))) { const a = [t, e, s, i, n, o]; if (!1 === this.$emit("transform", { matrix: a, oldMatrix: this.$matrix })) return this; this.$matrix = a, this.style.transform = `matrix(${a.join(", ")})` } return this } $getTransform() { return this.$matrix.slice() } $resetTransform() { return this.$setTransform([1, 0, 0, 1, 0, 0]) } } zt.$name = "cropper-image", zt.$version = "2.0.0-beta.1"; const At = new WeakMap; class Et extends Ct { constructor() { super(...arguments), this.$onCanvasChange = null, this.$onCanvasActionEnd = null, this.$onCanvasActionStart = null, this.$style = ":host{display:block;height:0;left:0;outline:var(--theme-color) solid 1px;position:relative;top:0;width:0}:host([transparent]){outline-color:transparent}", this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.slottable = !1, this.themeColor = "rgba(0, 0, 0, 0.65)" } set $canvas(t) { At.set(this, t) } get $canvas() { return At.get(this) } static get observedAttributes() { return super.observedAttributes.concat(["height", "width", "x", "y"]) } connectedCallback() { super.connectedCallback(); const t = this.closest(this.$getTagNameOf("cropper-canvas")); if (t) { this.$canvas = t, this.style.position = "absolute"; const e = t.querySelector(this.$getTagNameOf("cropper-selection")); e && (this.$onCanvasActionStart = t => { e.hidden && "select" === t.detail.action && (this.hidden = !1) }, this.$onCanvasActionEnd = t => { e.hidden && "select" === t.detail.action && (this.hidden = !0) }, this.$onCanvasChange = t => { const { x: s, y: i, width: n, height: o } = t.detail; this.$change(s, i, n, o), (e.hidden || 0 === s && 0 === i && 0 === n && 0 === o) && (this.hidden = !0) }, rt(t, "actionstart", this.$onCanvasActionStart), rt(t, "actionend", this.$onCanvasActionEnd), rt(t, "change", this.$onCanvasChange)) } this.$render() } disconnectedCallback() { const { $canvas: t } = this; t && (this.$onCanvasActionStart && (at(t, "actionstart", this.$onCanvasActionStart), this.$onCanvasActionStart = null), this.$onCanvasActionEnd && (at(t, "actionend", this.$onCanvasActionEnd), this.$onCanvasActionEnd = null), this.$onCanvasChange && (at(t, "change", this.$onCanvasChange), this.$onCanvasChange = null)), super.disconnectedCallback() } $change(t, e, s = this.width, i = this.height) { return F(t) && F(e) && F(s) && F(i) && (t !== this.x || e !== this.y || s !== this.width || i !== this.height) ? (this.hidden && (this.hidden = !1), this.x = t, this.y = e, this.width = s, this.height = i, this.$render()) : this } $reset() { return this.$change(0, 0, 0, 0) } $render() { return this.$setStyles({ transform: `translate(${this.x}px, ${this.y}px)`, width: this.width, height: this.height, outlineWidth: e.innerWidth }) } } Et.$name = "cropper-shade", Et.$version = "2.0.0-beta.1"; class Mt extends Ct { constructor() { super(...arguments), this.$onCanvasCropEnd = null, this.$onCanvasCropStart = null, this.$style = ':host{background-color:var(--theme-color);display:block}:host([action=move]),:host([action=select]){height:100%;left:0;position:absolute;top:0;width:100%}:host([action=move]){cursor:move}:host([action=select]){cursor:crosshair}:host([action$=-resize]){background-color:transparent;height:15px;position:absolute;width:15px}:host([action$=-resize]):after{background-color:var(--theme-color);content:"";display:block;height:5px;left:50%;position:absolute;top:50%;transform:translate(-50%,-50%);width:5px}:host([action=n-resize]),:host([action=s-resize]){cursor:ns-resize;left:50%;transform:translateX(-50%);width:100%}:host([action=n-resize]){top:-8px}:host([action=s-resize]){bottom:-8px}:host([action=e-resize]),:host([action=w-resize]){cursor:ew-resize;height:100%;top:50%;transform:translateY(-50%)}:host([action=e-resize]){right:-8px}:host([action=w-resize]){left:-8px}:host([action=ne-resize]){cursor:nesw-resize;right:-8px;top:-8px}:host([action=nw-resize]){cursor:nwse-resize;left:-8px;top:-8px}:host([action=se-resize]){bottom:-8px;cursor:nwse-resize;right:-8px}:host([action=se-resize]):after{height:15px;width:15px}@media (pointer:coarse){:host([action=se-resize]):after{height:10px;width:10px}}@media (pointer:fine){:host([action=se-resize]):after{height:5px;width:5px}}:host([action=sw-resize]){bottom:-8px;cursor:nesw-resize;left:-8px}:host([plain]){background-color:transparent}', this.action = "none", this.plain = !1, this.slottable = !1, this.themeColor = "rgba(51, 153, 255, 0.5)" } static get observedAttributes() { return super.observedAttributes.concat(["action", "plain"]) } } Mt.$name = "cropper-handle", Mt.$version = "2.0.0-beta.1"; const Tt = new WeakMap; class Dt extends Ct { constructor() { super(...arguments), this.$onCanvasAction = null, this.$onCanvasActionStart = null, this.$onDocumentKeyDown = null, this.$style = ':host{display:block;left:0;position:relative;right:0}:host([outlined]){outline:1px solid var(--theme-color)}:host([multiple]){outline:1px dashed hsla(0,0%,100%,.5)}:host([multiple]):after{bottom:0;content:"";cursor:pointer;display:block;left:0;position:absolute;right:0;top:0}:host([multiple][active]){outline-color:var(--theme-color);z-index:1}:host([multiple])>*{visibility:hidden}:host([multiple][active])>*{visibility:visible}:host([multiple][active]):after{display:none}', this.x = 0, this.y = 0, this.width = 0, this.height = 0, this.aspectRatio = NaN, this.initialAspectRatio = NaN, this.initialCoverage = NaN, this.active = !1, this.movable = !1, this.resizable = !1, this.zoomable = !1, this.multiple = !1, this.keyboard = !1, this.outlined = !1, this.precise = !1 } set $canvas(t) { Tt.set(this, t) } get $canvas() { return Tt.get(this) } static get observedAttributes() { return super.observedAttributes.concat(["active", "aspect-ratio", "height", "initial-aspect-ratio", "initial-coverage", "keyboard", "movable", "multiple", "outlined", "precise", "resizable", "width", "x", "y", "zoomable"]) } $propertyChangedCallback(t, e, s) { if (!Object.is(s, e)) switch (super.$propertyChangedCallback(t, e, s), t) { case "aspectRatio": Z(s) || (this.aspectRatio = NaN); break; case "initialAspectRatio": Z(s) || (this.initialAspectRatio = NaN); break; case "initialCoverage": (!Z(s) || s > 1) && (this.initialCoverage = NaN); break; case "keyboard": this.$nextTick((() => { this.$canvas && (s ? this.$onDocumentKeyDown || (this.$onDocumentKeyDown = this.$handleKeyDown.bind(this), rt(this.ownerDocument, "keydown", this.$onDocumentKeyDown)) : this.$onDocumentKeyDown && (at(this.ownerDocument, "keydown", this.$onDocumentKeyDown), this.$onDocumentKeyDown = null)) })); break; case "multiple": this.$nextTick((() => { this.$canvas && (s ? (this.active = !0, this.$onCanvasActionStart || (this.$onCanvasActionStart = this.$handleActionStart.bind(this), rt(this.$canvas, "actionstart", this.$onCanvasActionStart))) : (this.$onCanvasActionStart && (at(this.$canvas, "actionstart", this.$onCanvasActionStart), this.$onCanvasActionStart = null), this.$getSelections().forEach(((t, e) => { e > 0 && this.$removeSelection(t) })), this.active = !1)) })) } } connectedCallback() { super.connectedCallback(), this.multiple && !this.active && (this.active = !0); const t = this.closest(this.$getTagNameOf("cropper-canvas")); if (t) { this.$canvas = t, this.$setStyles({ position: "absolute", transform: `translate(${this.x}px, ${this.y}px)` }), this.hidden || this.$render(); const { initialCoverage: e, parentElement: s } = this; if (Z(e) && s) { const t = this.aspectRatio || this.initialAspectRatio, { offsetWidth: i, offsetHeight: n } = s; let o = i * e, a = n * e; Z(t) && ({ width: o, height: a } = gt({ aspectRatio: t, width: o, height: a })), this.$change(this.x, this.y, o, a), this.$center() } this.$onCanvasAction = this.$handleAction.bind(this), rt(t, "action", this.$onCanvasAction) } else this.$render() } disconnectedCallback() { const { $canvas: t } = this; t && this.$onCanvasAction && (at(t, "action", this.$onCanvasAction), this.$onCanvasAction = null), super.disconnectedCallback() } $getSelections() { let t = []; return this.parentElement && (t = Array.from(this.parentElement.querySelectorAll(this.$getTagNameOf("cropper-selection")))), t } $createSelection() { const t = this.cloneNode(!0); return this.hasAttribute("id") && t.removeAttribute("id"), this.active = !1, this.parentElement && this.parentElement.insertBefore(t, this.nextSibling), t } $removeSelection(t = this) { if (this.parentElement) { const e = this.$getSelections(); if (e.length > 1) { const s = e.indexOf(t), i = e[s + 1] || e[s - 1]; i && (this.parentElement.removeChild(t), i.active = !0, i.$emit("change", { x: i.x, y: i.y, width: i.width, height: i.height })) } else this.$reset(), this.hidden = !0 } } $handleActionStart(t) { if (this.hidden || !this.multiple || this.active) return; const { detail: e } = t, { relatedEvent: s } = e; s.target === this && this.parentElement && (this.$getSelections().forEach((t => { t.active = !1 })), this.active = !0, this.$emit("change", { x: this.x, y: this.y, width: this.width, height: this.height })) } $handleAction(t) { if (this.multiple && !this.active) return; const { currentTarget: e, detail: s } = t; if (e && s) { const { relatedEvent: i } = s; let { action: n } = s; if (!n && this.multiple && (n = null == i ? void 0 : i.target.action), !n || this.hidden && "select" !== n) return; const o = s.endX - s.startX, a = s.endY - s.startY, { width: r, height: h } = this; let { aspectRatio: c } = this; switch (!Z(c) && t.shiftKey && (c = Z(r) && Z(h) ? r / h : 1), n) { case "select": { const { $canvas: t } = this, i = ut(e); (this.multiple && !this.hidden ? this.$createSelection() : this).$change(s.startX - i.left, s.startY - i.top, o, a, c), n = "se-resize", o < 0 ? a > 0 ? n = "sw-resize" : a < 0 && (n = "nw-resize") : o > 0 && a < 0 && (n = "ne-resize"), t && (t.$action = n); break } case "move": !this.movable || i && !this.contains(i.target) || this.$move(o, a); break; case "scale": if (i && this.zoomable) { const t = ut(e); this.$zoom(s.scale, i.pageX - t.left, i.pageY - t.top) } break; default: this.$resize(n, o, a, c) } } } $handleKeyDown(t) { if (!(this.hidden || !this.keyboard || this.multiple && !this.active || t.defaultPrevented)) switch (t.key) { case "Backspace": t.metaKey && (t.preventDefault(), this.$removeSelection()); break; case "Delete": t.preventDefault(), this.$removeSelection(); break; case "ArrowLeft": t.preventDefault(), this.$move(-1, 0); break; case "ArrowRight": t.preventDefault(), this.$move(1, 0); break; case "ArrowUp": t.preventDefault(), this.$move(0, -1); break; case "ArrowDown": t.preventDefault(), this.$move(0, 1); break; case "+": t.preventDefault(), this.$zoom(.1); break; case "-": t.preventDefault(), this.$zoom(-.1) } } $center() { const { parentElement: t } = this; if (!t) return this; const e = (t.offsetWidth - this.width) / 2, s = (t.offsetHeight - this.height) / 2; return this.$change(e, s) } $move(t, e = t) { return this.$moveTo(this.x + t, this.y + e) } $moveTo(t, e = t) { return this.movable ? this.$change(t, e) : this } $resize(t, e = 0, s = 0, i = this.aspectRatio) { if (!this.resizable) return this; const n = Z(i), { $canvas: o } = this; let { x: a, y: r, width: h, height: c } = this; switch (t) { case "n-resize": r += s, c -= s, c < 0 && (t = "s-resize", c = -c, r -= c), n && (a += (e = s * i) / 2, h -= e, h < 0 && (h = -h, a -= h)); break; case "e-resize": h += e, h < 0 && (t = "w-resize", h = -h, a -= h), n && (r -= (s = e / i) / 2, c += s, c < 0 && (c = -c, r -= c)); break; case "s-resize": c += s, c < 0 && (t = "n-resize", c = -c, r -= c), n && (a -= (e = s * i) / 2, h += e, h < 0 && (h = -h, a -= h)); break; case "w-resize": a += e, h -= e, h < 0 && (t = "e-resize", h = -h, a -= h), n && (r += (s = e / i) / 2, c -= s, c < 0 && (c = -c, r -= c)); break; case "ne-resize": n && (s = -e / i), r += s, c -= s, h += e, h < 0 && c < 0 ? (t = "sw-resize", h = -h, c = -c, a -= h, r -= c) : h < 0 ? (t = "nw-resize", h = -h, a -= h) : c < 0 && (t = "se-resize", c = -c, r -= c); break; case "nw-resize": n && (s = e / i), a += e, r += s, h -= e, c -= s, h < 0 && c < 0 ? (t = "se-resize", h = -h, c = -c, a -= h, r -= c) : h < 0 ? (t = "ne-resize", h = -h, a -= h) : c < 0 && (t = "sw-resize", c = -c, r -= c); break; case "se-resize": n && (s = e / i), h += e, c += s, h < 0 && c < 0 ? (t = "nw-resize", h = -h, c = -c, a -= h, r -= c) : h < 0 ? (t = "sw-resize", h = -h, a -= h) : c < 0 && (t = "ne-resize", c = -c, r -= c); break; case "sw-resize": n && (s = -e / i), a += e, h -= e, c += s, h < 0 && c < 0 ? (t = "ne-resize", h = -h, c = -c, a -= h, r -= c) : h < 0 ? (t = "se-resize", h = -h, a -= h) : c < 0 && (t = "nw-resize", c = -c, r -= c) }return o && o.$setAction(t), this.$change(a, r, h, c) } $zoom(t, e, s) { if (!this.zoomable || 0 === t) return this; t < 0 ? t = 1 / (1 - t) : t += 1; const { width: i, height: n } = this, o = i * t, a = n * t; let r = this.x, h = this.y; return F(e) && F(s) ? (r -= (o - i) * ((e - this.x) / i), h -= (a - n) * ((s - this.y) / n)) : (r -= (o - i) / 2, h -= (a - n) / 2), this.$change(r, h, o, a) } $change(t, e, s = this.width, i = this.height, n = this.aspectRatio) { return F(t) && F(e) && F(s) && F(i) ? (this.precise || (t = Math.round(t), e = Math.round(e), s = Math.round(s), i = Math.round(i)), t === this.x && e === this.y && s === this.width && i === this.height ? this : (this.hidden && (this.hidden = !1), Z(n) && ({ width: s, height: i } = gt({ aspectRatio: n, width: s, height: i }, "cover")), !1 === this.$emit("change", { x: t, y: e, width: s, height: i }) ? this : (this.x = t, this.y = e, this.width = s, this.height = i, this.$render()))) : this } $reset() { return this.$change(0, 0, 0, 0) } $render() { return this.$setStyles({ transform: `translate(${this.x}px, ${this.y}px)`, width: this.width, height: this.height }) } $toCanvas(t) { return new Promise(((e, s) => { if (!this.isConnected) return void s(new Error("The current element is not connected to the DOM.")); const i = document.createElement("canvas"), { $canvas: n, width: o, height: a } = this; if (i.width = o, i.height = a, !n) return void e(i); const r = n.querySelector(this.$getTagNameOf("cropper-image")); r ? r.$ready().then((s => { const n = i.getContext("2d"); if (n) { const [e, h, c, l, d, p] = r.$getTransform(), u = s.naturalWidth / 2, $ = s.naturalHeight / 2, m = -this.x, g = -this.y, b = (m * l - c * g) / (e * l - c * h), f = (g - h * b) / l, v = e * b + c * f + d, w = h * b + l * f + p; n.fillStyle = "transparent", n.fillRect(0, 0, o, a), V(t) && _(t.beforeDraw) && t.beforeDraw.call(this, n, i), n.save(), n.translate(u, $), n.transform(e, h, c, l, v, w), n.translate(-u, -$), n.drawImage(s, 0, 0), n.restore() } e(i) })).catch(s) : e(i) })).then((e => { if (V(t) && (Z(t.width) || Z(t.height))) { let { width: s, height: i } = e; if (({ width: s, height: i } = gt({ aspectRatio: s / i, width: t.width, height: t.height })), s !== e.width) { const t = document.createElement("canvas"), n = t.getContext("2d"); return t.width = s, t.height = i, n && n.drawImage(e, 0, 0, s, i), t } } return e })) } } Dt.$name = "cropper-selection", Dt.$version = "2.0.0-beta.1"; class Pt extends Ct { constructor() { super(...arguments), this.$style = ":host{display:flex;flex-direction:column;position:relative;touch-action:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}:host([bordered]){border:1px dashed var(--theme-color)}:host([covered]){bottom:0;left:0;position:absolute;right:0;top:0}:host>span{display:flex;flex:1}:host>span+span{border-top:1px dashed var(--theme-color)}:host>span>span{flex:1}:host>span>span+span{border-left:1px dashed var(--theme-color)}", this.bordered = !1, this.columns = 3, this.covered = !1, this.rows = 3, this.slottable = !1, this.themeColor = "rgba(238, 238, 238, 0.5)" } static get observedAttributes() { return super.observedAttributes.concat(["bordered", "columns", "covered", "rows"]) } $propertyChangedCallback(t, e, s) { Object.is(s, e) || (super.$propertyChangedCallback(t, e, s), "rows" !== t && "columns" !== t || this.$render()) } connectedCallback() { super.connectedCallback(), this.$render() } $render() { const t = this.$getShadowRoot(), e = document.createDocumentFragment(); for (let t = 0; t < this.rows; t += 1) { const t = document.createElement("span"); t.setAttribute("role", "row"); for (let e = 0; e < this.columns; e += 1) { const e = document.createElement("span"); e.setAttribute("role", "gridcell"), t.appendChild(e) } e.appendChild(t) } t && (t.innerHTML = "", t.appendChild(e)) } } Pt.$name = "cropper-grid", Pt.$version = "2.0.0-beta.1"; class It extends Ct { constructor() { super(...arguments), this.$style = ':host{display:inline-block;height:1em;position:relative;touch-action:none;-webkit-user-select:none;-moz-user-select:none;user-select:none;vertical-align:middle;width:1em}:host:after,:host:before{background-color:var(--theme-color);content:"";display:block;position:absolute}:host:before{height:1px;left:0;top:50%;transform:translateY(-50%);width:100%}:host:after{height:100%;left:50%;top:0;transform:translateX(-50%);width:1px}:host([centered]){left:50%;position:absolute;top:50%;transform:translate(-50%,-50%)}', this.centered = !1, this.slottable = !1, this.themeColor = "rgba(238, 238, 238, 0.5)" } static get observedAttributes() { return super.observedAttributes.concat(["centered"]) } } It.$name = "cropper-crosshair", It.$version = "2.0.0-beta.1"; const Ot = new WeakMap, Rt = new WeakMap, Nt = new WeakMap; class Yt extends Ct { constructor() { super(...arguments), this.$onSelectionChange = null, this.$onSourceImageLoad = null, this.$onSourceImageTransform = null, this.$scale = 1, this.$style = ":host{display:block;height:100%;overflow:hidden;position:relative;width:100%}", this.resize = "vertical", this.selection = "", this.slottable = !1 } set $image(t) { Ot.set(this, t) } get $image() { return Ot.get(this) } set $sourceImage(t) { Nt.set(this, t) } get $sourceImage() { return Nt.get(this) } set $selection(t) { Rt.set(this, t) } get $selection() { return Rt.get(this) } static get observedAttributes() { return super.observedAttributes.concat(["resize", "selection"]) } connectedCallback() { super.connectedCallback(); let t = null; if (t = this.selection ? this.ownerDocument.querySelector(this.selection) : this.closest(this.$getTagNameOf("cropper-selection")), tt(t)) { this.$selection = t, this.$onSelectionChange = this.$handleSelectionChange.bind(this), rt(t, "change", this.$onSelectionChange); const e = t.closest(this.$getTagNameOf("cropper-canvas")); if (e) { const t = e.querySelector(this.$getTagNameOf("cropper-image")); t && (this.$sourceImage = t, this.$image = t.cloneNode(!0), this.$getShadowRoot().appendChild(this.$image), this.$onSourceImageLoad = this.$handleSourceImageLoad.bind(this), this.$onSourceImageTransform = this.$handleSourceImageTransform.bind(this), rt(t.$image, "load", this.$onSourceImageLoad), rt(t, "transform", this.$onSourceImageTransform)) } this.$render() } } disconnectedCallback() { const { $selection: t, $sourceImage: e } = this; t && this.$onSelectionChange && (at(t, "change", this.$onSelectionChange), this.$onSelectionChange = null), e && this.$onSourceImageLoad && (at(e.$image, "load", this.$onSourceImageLoad), this.$onSourceImageLoad = null), e && this.$onSourceImageTransform && (at(e, "transform", this.$onSourceImageTransform), this.$onSourceImageTransform = null), super.disconnectedCallback() } $handleSelectionChange(t) { this.$render(t.detail) } $handleSourceImageLoad() { const { $image: t, $sourceImage: e } = this, s = t.getAttribute("src"), i = e.getAttribute("src"); i && i !== s && (t.setAttribute("src", i), t.$ready((() => { setTimeout((() => { const { x: t, y: s } = this.$selection; this.$transformImageByOffset(e.$getTransform(), -t, -s) })) }))) } $handleSourceImageTransform(t) { const { x: e, y: s } = this.$selection; this.$transformImageByOffset(t.detail.matrix, -e, -s) } $render(t) { const { x: e, y: s, width: i, height: n } = t || this.$selection, o = {}, { clientWidth: a, clientHeight: r } = this; let h = a, c = r, l = NaN; switch (this.resize) { case "both": l = 1, h = i, c = n, o.width = i, o.height = n; break; case "horizontal": l = r / n, h = i * l, o.width = h; break; case "vertical": l = a / i, c = n * l, o.height = c; break; default: a > 0 ? l = a / i : r > 0 && (l = r / n) }this.$scale = l, this.$setStyles(o), this.$sourceImage && this.$transformImageByOffset(this.$sourceImage.$getTransform(), -e, -s) } $transformImageByOffset(t, e, s) { const { $image: i, $scale: n, $sourceImage: o } = this; if (o && i && n > 0) { const [o, a, r, h, c, l] = t, d = (e * h - r * s) / (o * h - r * a), p = (s - a * d) / h, u = o * d + r * p + c, $ = a * d + h * p + l; i.$ready((t => { this.$setStyles.call(i, { width: t.naturalWidth * n, height: t.naturalHeight * n }) })), i.$setTransform(o, a, r, h, u * n, $ * n) } } } Yt.$name = "cropper-viewer", Yt.$version = "2.0.0-beta.1"; const Xt = /^img|canvas$/, Lt = /<(\/?(?:script|style)[^>]*)>/gi, Wt = { template: '<cropper-canvas background><cropper-image></cropper-image><cropper-shade hidden></cropper-shade><cropper-handle action="select" plain></cropper-handle><cropper-selection initial-coverage="0.5" movable resizable zoomable><cropper-grid role="grid" bordered covered></cropper-grid><cropper-crosshair centered></cropper-crosshair><cropper-handle action="move" theme-color="rgba(255, 255, 255, 0.35)"></cropper-handle><cropper-handle action="n-resize"></cropper-handle><cropper-handle action="e-resize"></cropper-handle><cropper-handle action="s-resize"></cropper-handle><cropper-handle action="w-resize"></cropper-handle><cropper-handle action="ne-resize"></cropper-handle><cropper-handle action="nw-resize"></cropper-handle><cropper-handle action="se-resize"></cropper-handle><cropper-handle action="sw-resize"></cropper-handle></cropper-selection></cropper-canvas>' }; kt.$define(), It.$define(), Pt.$define(), Mt.$define(), zt.$define(), Dt.$define(), Et.$define(), Yt.$define(); class jt { constructor(t, e) { if (this.options = Wt, K(t) && (t = document.querySelector(t)), !tt(t) || !Xt.test(t.localName)) throw new Error("The first argument is required and must be an <img> or <canvas> element."); this.element = t, e = Object.assign(Object.assign({}, Wt), e), this.options = e; const { ownerDocument: s } = t; let { container: i } = e; if (i && (K(i) && (i = s.querySelector(i)), !tt(i))) throw new Error("The `container` option must be an element or a valid selector."); tt(i) || (i = t.parentElement ? t.parentElement : s.body), this.container = i; const n = t.localName; let o = ""; "img" === n ? ({ src: o } = t) : "canvas" === n && window.HTMLCanvasElement && (o = t.toDataURL()); const { template: a } = e; if (a && K(a)) { const e = document.createElement("template"), s = document.createDocumentFragment(); e.innerHTML = a.replace(Lt, "&lt;$1&gt;"), s.appendChild(e.content), Array.from(s.querySelectorAll("cropper-image")).forEach((e => { e.setAttribute("src", o), e.setAttribute("alt", t.alt || "The image to crop") })), t.parentElement ? (t.style.display = "none", i.insertBefore(s, t.nextSibling)) : i.appendChild(s) } } getCropperCanvas() { return this.container.querySelector("cropper-canvas") } getCropperImage() { return this.container.querySelector("cropper-image") } getCropperSelection() { return this.container.querySelector("cropper-selection") } getCropperSelections() { return this.container.querySelectorAll("cropper-selection") } } jt.version = "2.0.0-beta.1"; export { $ as ACTION_MOVE, f as ACTION_NONE, w as ACTION_RESIZE_EAST, v as ACTION_RESIZE_NORTH, k as ACTION_RESIZE_NORTHEAST, x as ACTION_RESIZE_NORTHWEST, y as ACTION_RESIZE_SOUTH, S as ACTION_RESIZE_SOUTHEAST, z as ACTION_RESIZE_SOUTHWEST, C as ACTION_RESIZE_WEST, g as ACTION_ROTATE, m as ACTION_SCALE, u as ACTION_SELECT, b as ACTION_TRANSFORM, A as ATTRIBUTE_ACTION, o as CROPPER_CANVAS, a as CROPPER_CROSSHAIR, r as CROPPER_GIRD, h as CROPPER_HANDLE, c as CROPPER_IMAGE, l as CROPPER_SELECTION, d as CROPPER_SHADE, p as CROPPER_VIEWER, kt as CropperCanvas, It as CropperCrosshair, Ct as CropperElement, Pt as CropperGrid, Mt as CropperHandle, zt as CropperImage, Dt as CropperSelection, Et as CropperShade, Yt as CropperViewer, L as EVENT_ACTION, W as EVENT_ACTION_END, j as EVENT_ACTION_MOVE, q as EVENT_ACTION_START, B as EVENT_CHANGE, O as EVENT_ERROR, R as EVENT_KEYDOWN, N as EVENT_LOAD, D as EVENT_POINTER_DOWN, P as EVENT_POINTER_MOVE, I as EVENT_POINTER_UP, Y as EVENT_RESIZE, E as EVENT_TOUCH_END, M as EVENT_TOUCH_MOVE, T as EVENT_TOUCH_START, H as EVENT_TRANSFORM, X as EVENT_WHEEL, i as HAS_POINTER_EVENT, t as IS_BROWSER, s as IS_TOUCH_DEVICE, n as NAMESPACE, e as WINDOW, jt as default, lt as emit, gt as getAdjustedSizes, ut as getOffset, tt as isElement, _ as isFunction, U as isNaN, F as isNumber, J as isObject, V as isPlainObject, Z as isPositiveNumber, K as isString, G as isUndefined, pt as nextTick, at as off, rt as on, ht as once, mt as toAngleInRadian, nt as toCamelCase, st as toKebabCase };
