@using Blazorise.Utilities
@typeparam TItem
@inherits ComponentBase

@if ( TypeHelper.IsDate( valueType ) )
{
    @dateFragment
}

@code {
    private RenderFragment dateFragment => builder =>
    {
        var type = typeof( DatePicker<> ).MakeGenericType( new[] { valueType } );

        builder.OpenComponent( 0, type );
        builder.AddAttribute( 1, nameof( DatePicker<object>.Date ), valueType switch
        {
            Type typeDateTime when typeDateTime == typeof( DateTime ) => (DateTime)( CellValue ?? (DateTime)default ),
            Type typeDateTimeNull when typeDateTimeNull == typeof( DateTime? ) => (DateTime?)( CellValue ?? (DateTime?)default ),
            Type typeDateOnly when typeDateOnly == typeof( DateOnly ) => (DateOnly)( CellValue ?? (DateOnly)default ),
            Type typeDateOnlyNull when typeDateOnlyNull == typeof( DateOnly? ) => (DateOnly?)( CellValue ?? (DateOnly?)default ),
            Type typeDateTimeOffset when typeDateTimeOffset == typeof( DateTimeOffset ) => (DateTimeOffset)( CellValue ?? (DateTimeOffset)default ),
            Type typeDateTimeOffsetNull when typeDateTimeOffsetNull == typeof( DateTimeOffset? ) => (DateTimeOffset?)( CellValue ?? (DateTimeOffset?)default ),
            _ => throw new InvalidOperationException( $"Unsupported type {valueType}" )
        } );
        builder.AddAttribute( 2, nameof( DatePicker<object>.DateChanged ), valueType switch
        {
            Type typeDateTime when typeDateTime == typeof( DateTime ) => EventCallback.Factory.Create<DateTime>( this, ( OnCellValueChanged<DateTime> ) ),
            Type typeDateTimeNull when typeDateTimeNull == typeof( DateTime? ) => EventCallback.Factory.Create<DateTime?>( this, ( OnCellValueChanged<DateTime?> ) ),
            Type typeDateOnly when typeDateOnly == typeof( DateOnly ) => EventCallback.Factory.Create<DateOnly>( this, ( OnCellValueChanged<DateOnly> ) ),
            Type typeDateOnlyNull when typeDateOnlyNull == typeof( DateOnly? ) => EventCallback.Factory.Create<DateOnly?>( this, ( OnCellValueChanged<DateOnly?> ) ),
            Type typeDateTimeOffset when typeDateTimeOffset == typeof( DateTimeOffset ) => EventCallback.Factory.Create<DateTimeOffset>( this, ( OnCellValueChanged<DateTimeOffset> ) ),
            Type typeDateTimeOffsetNull when typeDateTimeOffsetNull == typeof( DateTimeOffset? ) => EventCallback.Factory.Create<DateTimeOffset?>( this, ( OnCellValueChanged<DateTimeOffset?> ) ),
            _ => throw new InvalidOperationException( $"Unsupported type {valueType}" )
        } );
        builder.AddAttribute( 3, nameof( BaseInputComponent<object>.ReadOnly ), Column.Readonly );
        builder.AddAttribute( 4, nameof( DatePicker<object>.Pattern ), Column.ValidationPattern );
        builder.AddAttribute( 5, nameof( DatePicker<object>.InputMode ), Column.InputMode );
        builder.AddAttribute( 6, nameof( DatePicker<object>.Min ), Column.Min );
        builder.AddAttribute( 7, nameof( DatePicker<object>.Max ), Column.Max );
        builder.AddAttribute( 8, nameof( DatePicker<object>.FirstDayOfWeek ), Column.FirstDayOfWeek );
        builder.AddAttribute( 9, nameof( DatePicker<object>.InputFormat ), Column.InputFormat );
        builder.AddAttribute( 10, nameof( DatePicker<object>.DisabledDates ), Column.DisabledDates );
        builder.AddAttribute( 11, nameof( DatePicker<object>.DisabledDays ), Column.DisabledDays );
        builder.AddAttribute( 12, nameof( DatePicker<object>.Inline ), Column.Inline );
        builder.AddAttribute( 13, nameof( DatePicker<object>.DisableMobile ), Column.DisableMobile );
        builder.AddAttribute( 14, nameof( DatePicker<object>.StaticPicker ), Column.StaticPicker );
        builder.AddAttribute( 15, nameof( DatePicker<object>.DisplayFormat ), Column.DateDisplayFormat );
        builder.CloseComponent();
    };
}