/**
 * Bundled by jsDelivr using Rollup v2.79.1 and Terser v5.17.1.
 * Original file: /npm/@floating-ui/core@1.3.1/dist/floating-ui.core.browser.min.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function t(t) { return t.split("-")[1] } function e(t) { return "y" === t ? "height" : "width" } function n(t) { return t.split("-")[0] } function o(t) { return ["top", "bottom"].includes(n(t)) ? "x" : "y" } function i(i, r, a) { let { reference: l, floating: s } = i; const c = l.x + l.width / 2 - s.width / 2, f = l.y + l.height / 2 - s.height / 2, m = o(r), u = e(m), g = l[u] / 2 - s[u] / 2, d = "x" === m; let p; switch (n(r)) { case "top": p = { x: c, y: l.y - s.height }; break; case "bottom": p = { x: c, y: l.y + l.height }; break; case "right": p = { x: l.x + l.width, y: f }; break; case "left": p = { x: l.x - s.width, y: f }; break; default: p = { x: l.x, y: l.y } }switch (t(r)) { case "start": p[m] -= g * (a && d ? -1 : 1); break; case "end": p[m] += g * (a && d ? -1 : 1) }return p } const r = async (t, e, n) => { const { placement: o = "bottom", strategy: r = "absolute", middleware: a = [], platform: l } = n, s = a.filter(Boolean), c = await (null == l.isRTL ? void 0 : l.isRTL(e)); let f = await l.getElementRects({ reference: t, floating: e, strategy: r }), { x: m, y: u } = i(f, o, c), g = o, d = {}, p = 0; for (let n = 0; n < s.length; n++) { const { name: a, fn: h } = s[n], { x: y, y: x, data: w, reset: v } = await h({ x: m, y: u, initialPlacement: o, placement: g, strategy: r, middlewareData: d, rects: f, platform: l, elements: { reference: t, floating: e } }); m = null != y ? y : m, u = null != x ? x : u, d = { ...d, [a]: { ...d[a], ...w } }, v && p <= 50 && (p++, "object" == typeof v && (v.placement && (g = v.placement), v.rects && (f = !0 === v.rects ? await l.getElementRects({ reference: t, floating: e, strategy: r }) : v.rects), ({ x: m, y: u } = i(f, g, c))), n = -1) } return { x: m, y: u, placement: g, strategy: r, middlewareData: d } }; function a(t, e) { return "function" == typeof t ? t(e) : t } function l(t) { return "number" != typeof t ? function (t) { return { top: 0, right: 0, bottom: 0, left: 0, ...t } }(t) : { top: t, right: t, bottom: t, left: t } } function s(t) { return { ...t, top: t.y, left: t.x, right: t.x + t.width, bottom: t.y + t.height } } async function c(t, e) { var n; void 0 === e && (e = {}); const { x: o, y: i, platform: r, rects: c, elements: f, strategy: m } = t, { boundary: u = "clippingAncestors", rootBoundary: g = "viewport", elementContext: d = "floating", altBoundary: p = !1, padding: h = 0 } = a(e, t), y = l(h), x = f[p ? "floating" === d ? "reference" : "floating" : d], w = s(await r.getClippingRect({ element: null == (n = await (null == r.isElement ? void 0 : r.isElement(x))) || n ? x : x.contextElement || await (null == r.getDocumentElement ? void 0 : r.getDocumentElement(f.floating)), boundary: u, rootBoundary: g, strategy: m })), v = "floating" === d ? { ...c.floating, x: o, y: i } : c.reference, b = await (null == r.getOffsetParent ? void 0 : r.getOffsetParent(f.floating)), A = await (null == r.isElement ? void 0 : r.isElement(b)) && await (null == r.getScale ? void 0 : r.getScale(b)) || { x: 1, y: 1 }, R = s(r.convertOffsetParentRelativeRectToViewportRelativeRect ? await r.convertOffsetParentRelativeRectToViewportRelativeRect({ rect: v, offsetParent: b, strategy: m }) : v); return { top: (w.top - R.top + y.top) / A.y, bottom: (R.bottom - w.bottom + y.bottom) / A.y, left: (w.left - R.left + y.left) / A.x, right: (R.right - w.right + y.right) / A.x } } const f = Math.min, m = Math.max; function u(t, e, n) { return m(t, f(e, n)) } const g = n => ({ name: "arrow", options: n, async fn(i) { const { x: r, y: s, placement: c, rects: m, platform: g, elements: d } = i, { element: p, padding: h = 0 } = a(n, i) || {}; if (null == p) return {}; const y = l(h), x = { x: r, y: s }, w = o(c), v = e(w), b = await g.getDimensions(p), A = "y" === w, R = A ? "top" : "left", P = A ? "bottom" : "right", T = A ? "clientHeight" : "clientWidth", E = m.reference[v] + m.reference[w] - x[w] - m.floating[v], D = x[w] - m.reference[w], L = await (null == g.getOffsetParent ? void 0 : g.getOffsetParent(p)); let O = L ? L[T] : 0; O && await (null == g.isElement ? void 0 : g.isElement(L)) || (O = d.floating[T] || m.floating[v]); const k = E / 2 - D / 2, C = O / 2 - b[v] / 2 - 1, B = f(y[R], C), H = f(y[P], C), S = B, z = O - b[v] - H, F = O / 2 - b[v] / 2 + k, M = u(S, F, z), V = null != t(c) && F != M && m.reference[v] / 2 - (F < S ? B : H) - b[v] / 2 < 0 ? F < S ? S - F : z - F : 0; return { [w]: x[w] - V, data: { [w]: M, centerOffset: F - M + V } } } }), d = ["top", "right", "bottom", "left"], p = d.reduce(((t, e) => t.concat(e, e + "-start", e + "-end")), []), h = { left: "right", right: "left", bottom: "top", top: "bottom" }; function y(t) { return t.replace(/left|right|bottom|top/g, (t => h[t])) } function x(n, i, r) { void 0 === r && (r = !1); const a = t(n), l = o(n), s = e(l); let c = "x" === l ? a === (r ? "end" : "start") ? "right" : "left" : "start" === a ? "bottom" : "top"; return i.reference[s] > i.floating[s] && (c = y(c)), { main: c, cross: y(c) } } const w = { start: "end", end: "start" }; function v(t) { return t.replace(/start|end/g, (t => w[t])) } const b = function (e) { return void 0 === e && (e = {}), { name: "autoPlacement", options: e, async fn(o) { var i, r, l; const { rects: s, middlewareData: f, placement: m, platform: u, elements: g } = o, { crossAxis: d = !1, alignment: h, allowedPlacements: y = p, autoAlignment: w = !0, ...b } = a(e, o), A = void 0 !== h || y === p ? function (e, o, i) { return (e ? [...i.filter((n => t(n) === e)), ...i.filter((n => t(n) !== e))] : i.filter((t => n(t) === t))).filter((n => !e || t(n) === e || !!o && v(n) !== n)) }(h || null, w, y) : y, R = await c(o, b), P = (null == (i = f.autoPlacement) ? void 0 : i.index) || 0, T = A[P]; if (null == T) return {}; const { main: E, cross: D } = x(T, s, await (null == u.isRTL ? void 0 : u.isRTL(g.floating))); if (m !== T) return { reset: { placement: A[0] } }; const L = [R[n(T)], R[E], R[D]], O = [...(null == (r = f.autoPlacement) ? void 0 : r.overflows) || [], { placement: T, overflows: L }], k = A[P + 1]; if (k) return { data: { index: P + 1, overflows: O }, reset: { placement: k } }; const C = O.map((e => { const n = t(e.placement); return [e.placement, n && d ? e.overflows.slice(0, 2).reduce(((t, e) => t + e), 0) : e.overflows[0], e.overflows] })).sort(((t, e) => t[1] - e[1])), B = (null == (l = C.filter((e => e[2].slice(0, t(e[0]) ? 2 : 3).every((t => t <= 0))))[0]) ? void 0 : l[0]) || C[0][0]; return B !== m ? { data: { index: P + 1, overflows: O }, reset: { placement: B } } : {} } } }, A = function (e) { return void 0 === e && (e = {}), { name: "flip", options: e, async fn(o) { var i; const { placement: r, middlewareData: l, rects: s, initialPlacement: f, platform: m, elements: u } = o, { mainAxis: g = !0, crossAxis: d = !0, fallbackPlacements: p, fallbackStrategy: h = "bestFit", fallbackAxisSideDirection: w = "none", flipAlignment: b = !0, ...A } = a(e, o), R = n(r), P = n(f) === f, T = await (null == m.isRTL ? void 0 : m.isRTL(u.floating)), E = p || (P || !b ? [y(f)] : function (t) { const e = y(t); return [v(t), e, v(e)] }(f)); p || "none" === w || E.push(...function (e, o, i, r) { const a = t(e); let l = function (t, e, n) { const o = ["left", "right"], i = ["right", "left"], r = ["top", "bottom"], a = ["bottom", "top"]; switch (t) { case "top": case "bottom": return n ? e ? i : o : e ? o : i; case "left": case "right": return e ? r : a; default: return [] } }(n(e), "start" === i, r); return a && (l = l.map((t => t + "-" + a)), o && (l = l.concat(l.map(v)))), l }(f, b, w, T)); const D = [f, ...E], L = await c(o, A), O = []; let k = (null == (i = l.flip) ? void 0 : i.overflows) || []; if (g && O.push(L[R]), d) { const { main: t, cross: e } = x(r, s, T); O.push(L[t], L[e]) } if (k = [...k, { placement: r, overflows: O }], !O.every((t => t <= 0))) { var C, B; const t = ((null == (C = l.flip) ? void 0 : C.index) || 0) + 1, e = D[t]; if (e) return { data: { index: t, overflows: k }, reset: { placement: e } }; let n = null == (B = k.filter((t => t.overflows[0] <= 0)).sort(((t, e) => t.overflows[1] - e.overflows[1]))[0]) ? void 0 : B.placement; if (!n) switch (h) { case "bestFit": { var H; const t = null == (H = k.map((t => [t.placement, t.overflows.filter((t => t > 0)).reduce(((t, e) => t + e), 0)])).sort(((t, e) => t[1] - e[1]))[0]) ? void 0 : H[0]; t && (n = t); break } case "initialPlacement": n = f }if (r !== n) return { reset: { placement: n } } } return {} } } }; function R(t, e) { return { top: t.top - e.height, right: t.right - e.width, bottom: t.bottom - e.height, left: t.left - e.width } } function P(t) { return d.some((e => t[e] >= 0)) } const T = function (t) { return void 0 === t && (t = {}), { name: "hide", options: t, async fn(e) { const { rects: n } = e, { strategy: o = "referenceHidden", ...i } = a(t, e); switch (o) { case "referenceHidden": { const t = R(await c(e, { ...i, elementContext: "reference" }), n.reference); return { data: { referenceHiddenOffsets: t, referenceHidden: P(t) } } } case "escaped": { const t = R(await c(e, { ...i, altBoundary: !0 }), n.floating); return { data: { escapedOffsets: t, escaped: P(t) } } } default: return {} } } } }; function E(t) { const e = f(...t.map((t => t.left))), n = f(...t.map((t => t.top))); return { x: e, y: n, width: m(...t.map((t => t.right))) - e, height: m(...t.map((t => t.bottom))) - n } } const D = function (t) { return void 0 === t && (t = {}), { name: "inline", options: t, async fn(e) { const { placement: i, elements: r, rects: c, platform: u, strategy: g } = e, { padding: d = 2, x: p, y: h } = a(t, e), y = Array.from(await (null == u.getClientRects ? void 0 : u.getClientRects(r.reference)) || []), x = function (t) { const e = t.slice().sort(((t, e) => t.y - e.y)), n = []; let o = null; for (let t = 0; t < e.length; t++) { const i = e[t]; !o || i.y - o.y > o.height / 2 ? n.push([i]) : n[n.length - 1].push(i), o = i } return n.map((t => s(E(t)))) }(y), w = s(E(y)), v = l(d), b = await u.getElementRects({ reference: { getBoundingClientRect: function () { if (2 === x.length && x[0].left > x[1].right && null != p && null != h) return x.find((t => p > t.left - v.left && p < t.right + v.right && h > t.top - v.top && h < t.bottom + v.bottom)) || w; if (x.length >= 2) { if ("x" === o(i)) { const t = x[0], e = x[x.length - 1], o = "top" === n(i), r = t.top, a = e.bottom, l = o ? t.left : e.left, s = o ? t.right : e.right; return { top: r, bottom: a, left: l, right: s, width: s - l, height: a - r, x: l, y: r } } const t = "left" === n(i), e = m(...x.map((t => t.right))), r = f(...x.map((t => t.left))), a = x.filter((n => t ? n.left === r : n.right === e)), l = a[0].top, s = a[a.length - 1].bottom; return { top: l, bottom: s, left: r, right: e, width: e - r, height: s - l, x: r, y: l } } return w } }, floating: r.floating, strategy: g }); return c.reference.x !== b.reference.x || c.reference.y !== b.reference.y || c.reference.width !== b.reference.width || c.reference.height !== b.reference.height ? { reset: { rects: b } } : {} } } }, L = function (e) { return void 0 === e && (e = 0), { name: "offset", options: e, async fn(i) { const { x: r, y: l } = i, s = await async function (e, i) { const { placement: r, platform: l, elements: s } = e, c = await (null == l.isRTL ? void 0 : l.isRTL(s.floating)), f = n(r), m = t(r), u = "x" === o(r), g = ["left", "top"].includes(f) ? -1 : 1, d = c && u ? -1 : 1, p = a(i, e); let { mainAxis: h, crossAxis: y, alignmentAxis: x } = "number" == typeof p ? { mainAxis: p, crossAxis: 0, alignmentAxis: null } : { mainAxis: 0, crossAxis: 0, alignmentAxis: null, ...p }; return m && "number" == typeof x && (y = "end" === m ? -1 * x : x), u ? { x: y * d, y: h * g } : { x: h * g, y: y * d } }(i, e); return { x: r + s.x, y: l + s.y, data: s } } } }; function O(t) { return "x" === t ? "y" : "x" } const k = function (t) { return void 0 === t && (t = {}), { name: "shift", options: t, async fn(e) { const { x: i, y: r, placement: l } = e, { mainAxis: s = !0, crossAxis: f = !1, limiter: m = { fn: t => { let { x: e, y: n } = t; return { x: e, y: n } } }, ...g } = a(t, e), d = { x: i, y: r }, p = await c(e, g), h = o(n(l)), y = O(h); let x = d[h], w = d[y]; if (s) { const t = "y" === h ? "bottom" : "right"; x = u(x + p["y" === h ? "top" : "left"], x, x - p[t]) } if (f) { const t = "y" === y ? "bottom" : "right"; w = u(w + p["y" === y ? "top" : "left"], w, w - p[t]) } const v = m.fn({ ...e, [h]: x, [y]: w }); return { ...v, data: { x: v.x - i, y: v.y - r } } } } }, C = function (t) { return void 0 === t && (t = {}), { options: t, fn(e) { const { x: i, y: r, placement: l, rects: s, middlewareData: c } = e, { offset: f = 0, mainAxis: m = !0, crossAxis: u = !0 } = a(t, e), g = { x: i, y: r }, d = o(l), p = O(d); let h = g[d], y = g[p]; const x = a(f, e), w = "number" == typeof x ? { mainAxis: x, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...x }; if (m) { const t = "y" === d ? "height" : "width", e = s.reference[d] - s.floating[t] + w.mainAxis, n = s.reference[d] + s.reference[t] - w.mainAxis; h < e ? h = e : h > n && (h = n) } if (u) { var v, b; const t = "y" === d ? "width" : "height", e = ["top", "left"].includes(n(l)), o = s.reference[p] - s.floating[t] + (e && (null == (v = c.offset) ? void 0 : v[p]) || 0) + (e ? 0 : w.crossAxis), i = s.reference[p] + s.reference[t] + (e ? 0 : (null == (b = c.offset) ? void 0 : b[p]) || 0) - (e ? w.crossAxis : 0); y < o ? y = o : y > i && (y = i) } return { [d]: h, [p]: y } } } }, B = function (e) { return void 0 === e && (e = {}), { name: "size", options: e, async fn(i) { const { placement: r, rects: l, platform: s, elements: u } = i, { apply: g = (() => { }), ...d } = a(e, i), p = await c(i, d), h = n(r), y = t(r), x = "x" === o(r), { width: w, height: v } = l.floating; let b, A; "top" === h || "bottom" === h ? (b = h, A = y === (await (null == s.isRTL ? void 0 : s.isRTL(u.floating)) ? "start" : "end") ? "left" : "right") : (A = h, b = "end" === y ? "top" : "bottom"); const R = v - p[b], P = w - p[A], T = !i.middlewareData.shift; let E = R, D = P; if (x) { const t = w - p.left - p.right; D = y || T ? f(P, t) : t } else { const t = v - p.top - p.bottom; E = y || T ? f(R, t) : t } if (T && !y) { const t = m(p.left, 0), e = m(p.right, 0), n = m(p.top, 0), o = m(p.bottom, 0); x ? D = w - 2 * (0 !== t || 0 !== e ? t + e : m(p.left, p.right)) : E = v - 2 * (0 !== n || 0 !== o ? n + o : m(p.top, p.bottom)) } await g({ ...i, availableWidth: D, availableHeight: E }); const L = await s.getDimensions(u.floating); return w !== L.width || v !== L.height ? { reset: { rects: !0 } } : {} } } }; export { g as arrow, b as autoPlacement, r as computePosition, c as detectOverflow, A as flip, T as hide, D as inline, C as limitShift, L as offset, s as rectToClientRect, k as shift, B as size }; export default null;