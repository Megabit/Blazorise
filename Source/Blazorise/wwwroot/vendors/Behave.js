function BehaveHooks() { var e = {}; return { add: function (t, r) { var n; if ("object" == typeof t) for (n = 0; n < t.length; n++) { var a = t[n]; e[a] || (e[a] = []), e[a].push(r) } else e[t] || (e[t] = []), e[t].push(r) }, get: function (t) { if (e[t]) return e[t] } } } const _hooks = BehaveHooks(); export function Behave(e) { "function" != typeof String.prototype.repeat && (String.prototype.repeat = function (e) { if (e < 1) return ""; if (e % 2) return this.repeat(e - 1) + this; var t = this.repeat(e / 2); return t + t }), "function" != typeof Array.prototype.filter && (Array.prototype.filter = function (e) { if (null === this) throw new TypeError; var t = Object(this), r = t.length >>> 0; if ("function" != typeof e) throw new TypeError; for (var n = [], a = arguments[1], o = 0; o < r; o++)if (o in t) { var s = t[o]; e.call(a, s, o, t) && n.push(s) } return n }); var t, r, n, a = { textarea: null, replaceTab: !0, softTabs: !0, tabSize: 4, autoOpen: !0, overwrite: !0, autoStrip: !0, autoIndent: !0, fence: !1 }, o = { keyMap: [{ open: '"', close: '"', canBreak: !1 }, { open: "'", close: "'", canBreak: !1 }, { open: "(", close: ")", canBreak: !1 }, { open: "[", close: "]", canBreak: !0 }, { open: "{", close: "}", canBreak: !0 }] }, s = { _callHook: function (e, t) { var r = _hooks.get(e); if (t = "boolean" != typeof t || !1 !== t, r) if (t) { var n, o = a.textarea, i = o.value, c = s.cursor.get(); for (n = 0; n < r.length; n++)r[n].call(void 0, { editor: { element: o, text: i, levelsDeep: s.levelsDeep() }, caret: { pos: c }, lines: { current: s.cursor.getLine(i, c), total: s.editor.getLines(i) } }) } else for (n = 0; n < r.length; n++)r[n].call(void 0) }, defineNewLine: function () { var e = document.createElement("textarea"); e.value = "\n", r = 2 == e.value.length ? "\r\n" : "\n" }, defineTabSize: function (e) { void 0 === a.textarea.style.OTabSize ? void 0 === a.textarea.style.MozTabSize ? void 0 === a.textarea.style.tabSize || (a.textarea.style.tabSize = e) : a.textarea.style.MozTabSize = e : a.textarea.style.OTabSize = e }, cursor: { getLine: function (e, t) { return e.substring(0, t).split("\n").length }, get: function () { if ("number" == typeof document.createElement("textarea").selectionStart) return a.textarea.selectionStart; if (document.selection) { var e = 0, t = a.textarea.createTextRange(), r = document.selection.createRange().duplicate().getBookmark(); for (t.moveToBookmark(r); 0 !== t.moveStart("character", -1);)e++; return e } }, set: function (e, t) { if (t || (t = e), a.textarea.setSelectionRange) a.textarea.focus(), a.textarea.setSelectionRange(e, t); else if (a.textarea.createTextRange) { var r = a.textarea.createTextRange(); r.collapse(!0), r.moveEnd("character", t), r.moveStart("character", e), r.select() } }, selection: function () { var e, t, n, o, i, c = a.textarea, l = 0, u = 0; return "number" == typeof c.selectionStart && "number" == typeof c.selectionEnd ? (l = c.selectionStart, u = c.selectionEnd) : (t = document.selection.createRange()) && t.parentElement() == c && (o = (e = s.editor.get()).length, (n = c.createTextRange()).moveToBookmark(t.getBookmark()), (i = c.createTextRange()).collapse(!1), n.compareEndPoints("StartToEnd", i) > -1 ? l = u = o : (l = -n.moveStart("character", -o), l += e.slice(0, l).split(r).length - 1, n.compareEndPoints("EndToEnd", i) > -1 ? u = o : (u = -n.moveEnd("character", -o), u += e.slice(0, u).split(r).length - 1))), l != u && { start: l, end: u } } }, editor: { getLines: function (e) { return e.split("\n").length }, get: function () { return a.textarea.value.replace(/\r/g, "") }, set: function (e, t) { a.textarea.value = e, t && a.textarea.dispatchEvent(new Event("input", { bubbles: !0 })) } }, fenceRange: function () { if ("string" == typeof a.fence) { for (var e = s.editor.get(), t = s.cursor.get(), r = 0, n = e.indexOf(a.fence), o = 0; n >= 0 && (o++, !(t < n + r));)r += n + a.fence.length, n = (e = e.substring(n + a.fence.length)).indexOf(a.fence); return r < t && n + r > t && o % 2 == 0 } return !0 }, isEven: function (e, t) { return t % 2 }, levelsDeep: function () { var e, t, r = s.cursor.get(), n = s.editor.get().substring(0, r), a = 0; for (e = 0; e < n.length; e++)for (t = 0; t < o.keyMap.length; t++)o.keyMap[t].canBreak && (o.keyMap[t].open == n.charAt(e) && a++, o.keyMap[t].close == n.charAt(e) && a--); var i = 0, c = ["'", '"']; for (e = 0; e < o.keyMap.length; e++)if (o.keyMap[e].canBreak) for (t in c) i += n.split(c[t]).filter(s.isEven).join("").split(o.keyMap[e].open).length - 1; var l = a - i; return l >= 0 ? l : 0 }, deepExtend: function (e, t) { for (var r in t) t[r] && t[r].constructor && t[r].constructor === Object ? (e[r] = e[r] || {}, s.deepExtend(e[r], t[r])) : e[r] = t[r]; return e }, addEvent: function (e, t, r) { e.addEventListener ? e.addEventListener(t, r, !1) : e.attachEvent && e.attachEvent("on" + t, r) }, removeEvent: function (e, t, r) { e.addEventListener ? e.removeEventListener(t, r, !1) : e.attachEvent && e.detachEvent("on" + t, r) }, preventDefaultEvent: function (e) { e.preventDefault ? e.preventDefault() : e.returnValue = !1 } }, i = function (e) { if (s.fenceRange()) { if (9 == e.keyCode) { s.preventDefaultEvent(e); var r = !0; s._callHook("tab:before"); var n = s.cursor.selection(), a = s.cursor.get(), o = s.editor.get(); if (n) { for (var i = n.start; i--;)if ("\n" == o.charAt(i)) { n.start = i + 1; break } var c, l = o.substring(n.start, n.end), u = l.split("\n"); if (e.shiftKey) { for (c = 0; c < u.length; c++)u[c].substring(0, t.length) == t && (u[c] = u[c].substring(t.length)); l = u.join("\n"), s.editor.set(o.substring(0, n.start) + l + o.substring(n.end)), s.cursor.set(n.start, n.start + l.length) } else { for (c in u) u[c] = t + u[c]; l = u.join("\n"), s.editor.set(o.substring(0, n.start) + l + o.substring(n.end)), s.cursor.set(n.start, n.start + l.length) } } else { var f = o.substring(0, a), g = o.substring(a), v = f + t + g; e.shiftKey ? o.substring(a - t.length, a) == t && (v = o.substring(0, a - t.length) + g, s.editor.set(v), s.cursor.set(a - t.length)) : (s.editor.set(v), s.cursor.set(a + t.length), r = !1) } s._callHook("tab:after") } return r } }, c = function (e) { if (s.fenceRange() && 13 == e.keyCode) { s.preventDefaultEvent(e), s._callHook("enter:before"); var n, a, i = s.cursor.get(), c = s.editor.get(), l = c.substring(0, i), u = c.substring(i), f = l.charAt(l.length - 1), g = u.charAt(0), v = s.levelsDeep(), p = "", d = ""; if (v) { for (; v--;)p += t; for (n = (p = p).length + 1, a = 0; a < o.keyMap.length; a++)o.keyMap[a].open == f && o.keyMap[a].close == g && (d = r) } else n = 1; var h = l + r + p + d + p.substring(0, p.length - t.length) + u; s.editor.set(h), s.cursor.set(i + n), s._callHook("enter:after") } }, l = function (e) { if (s.fenceRange() && 8 == e.keyCode) { s.preventDefaultEvent(e), s._callHook("delete:before"); var t, r = s.cursor.get(), n = s.editor.get(), a = n.substring(0, r), i = n.substring(r), c = a.charAt(a.length - 1), l = i.charAt(0); if (!1 === s.cursor.selection()) { for (t = 0; t < o.keyMap.length; t++)if (o.keyMap[t].open == c && o.keyMap[t].close == l) { var u = n.substring(0, r - 1) + n.substring(r + 1); return s.editor.set(u), void s.cursor.set(r - 1) } u = n.substring(0, r - 1) + n.substring(r); s.editor.set(u, !0), s.cursor.set(r - 1) } else { var f = s.cursor.selection(); u = n.substring(0, f.start) + n.substring(f.end); s.editor.set(u, !0), s.cursor.set(r) } s._callHook("delete:after") } }, u = function (e, t) { s.preventDefaultEvent(t), s._callHook("openChar:before"); var r = s.cursor.get(), n = s.editor.get(), o = n.substring(0, r), i = n.substring(r), c = o + e.open + e.close + i; a.textarea.value = c, s.cursor.set(r + 1), s._callHook("openChar:after") }, f = function (e, t) { var r = s.cursor.get(); return s.editor.get().substring(r, r + 1) == e.close && (s.preventDefaultEvent(t), s._callHook("closeChar:before"), s.cursor.set(s.cursor.get() + 1), s._callHook("closeChar:after"), !0) }, g = { filter: function (e) { if (s.fenceRange()) { var t = e.which || e.keyCode; if (39 != t && (40 != t || 0 !== e.which)) { var r, n = String.fromCharCode(t); for (r = 0; r < o.keyMap.length; r++) { if (o.keyMap[r].close == n) !(a.overwrite && f(o.keyMap[r], e)) && o.keyMap[r].open == n && a.autoOpen && u(o.keyMap[r], e); else o.keyMap[r].open == n && a.autoOpen && u(o.keyMap[r], e) } } } }, listen: function () { a.replaceTab && s.addEvent(a.textarea, "keydown", i), a.autoIndent && s.addEvent(a.textarea, "keydown", c), a.autoStrip && s.addEvent(a.textarea, "keydown", l), s.addEvent(a.textarea, "keypress", g.filter), s.addEvent(a.textarea, "keydown", function () { s._callHook("keydown") }), s.addEvent(a.textarea, "keyup", function () { s._callHook("keyup") }), s.addEvent(a.textarea, "blur", function () { a.textarea.dispatchEvent(new Event("change", { bubbles: !0 })) }) } }; this.destroy = function () { s.removeEvent(a.textarea, "keydown", i), s.removeEvent(a.textarea, "keydown", c), s.removeEvent(a.textarea, "keydown", l), s.removeEvent(a.textarea, "keypress", g.filter) }, (n = e).textarea && (s._callHook("init:before", !1), s.deepExtend(a, n), s.defineNewLine(), a.softTabs ? t = " ".repeat(a.tabSize) : (t = "\t", s.defineTabSize(a.tabSize)), g.listen(), s._callHook("init:after", !1)) }